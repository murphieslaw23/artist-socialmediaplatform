/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Upy API Documentation
 * API documentation of Upy - a social community platform for Artists.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AlbumHasArtworksModel
 */
export interface AlbumHasArtworksModel {
    /**
     * 
     * @type {Array<AlbumHasArtworksModelArtworkAlbumHasWorks>}
     * @memberof AlbumHasArtworksModel
     */
    artworkAlbumHasWorks?: Array<AlbumHasArtworksModelArtworkAlbumHasWorks>;
}
/**
 * 
 * @export
 * @interface AlbumHasArtworksModelArtworkAlbumHasWorks
 */
export interface AlbumHasArtworksModelArtworkAlbumHasWorks {
    /**
     * 
     * @type {ArtworkLiteModel}
     * @memberof AlbumHasArtworksModelArtworkAlbumHasWorks
     */
    artworks?: ArtworkLiteModel;
}
/**
 * 
 * @export
 * @interface AlbumLiteModel
 */
export interface AlbumLiteModel {
    /**
     * 
     * @type {number}
     * @memberof AlbumLiteModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AlbumLiteModel
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof AlbumLiteModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumLiteModel
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof AlbumLiteModel
     */
    isPublic?: AlbumLiteModel.IsPublicEnum;
    /**
     * 
     * @type {string}
     * @memberof AlbumLiteModel
     */
    createdAt?: string;
    /**
     * 
     * @type {AlbumLiteModelCount}
     * @memberof AlbumLiteModel
     */
    count?: AlbumLiteModelCount;
}

/**
 * @export
 * @namespace AlbumLiteModel
 */
export namespace AlbumLiteModel {
    /**
     * @export
     * @enum {string}
     */
    export enum IsPublicEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface AlbumLiteModelCount
 */
export interface AlbumLiteModelCount {
    /**
     * 
     * @type {number}
     * @memberof AlbumLiteModelCount
     */
    artworkAlbumHasWorks?: number;
}
/**
 * 
 * @export
 * @interface AlbumModel
 */
export interface AlbumModel extends AlbumLiteModel {
    /**
     * 
     * @type {Array<AlbumHasArtworksModelArtworkAlbumHasWorks>}
     * @memberof AlbumModel
     */
    artworkAlbumHasWorks?: Array<AlbumHasArtworksModelArtworkAlbumHasWorks>;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof AlbumModel
     */
    users?: UserLiteModel;
}

/**
 * @export
 * @namespace AlbumModel
 */
export namespace AlbumModel {
}
/**
 * 
 * @export
 * @interface AlbumsAddworkBody
 */
export interface AlbumsAddworkBody {
    /**
     * 
     * @type {number}
     * @memberof AlbumsAddworkBody
     */
    albumId: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlbumsAddworkBody
     */
    workIds: Array<number>;
}
/**
 * 
 * @export
 * @interface AlbumsBody
 */
export interface AlbumsBody {
    /**
     * 
     * @type {number}
     * @memberof AlbumsBody
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof AlbumsBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumsBody
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof AlbumsBody
     */
    isPublic?: AlbumsBody.IsPublicEnum;
}

/**
 * @export
 * @namespace AlbumsBody
 */
export namespace AlbumsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum IsPublicEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface AlbumsCreateBody
 */
export interface AlbumsCreateBody {
    /**
     * 
     * @type {string}
     * @memberof AlbumsCreateBody
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumsCreateBody
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof AlbumsCreateBody
     */
    isPublic: AlbumsCreateBody.IsPublicEnum;
    /**
     * 
     * @type {string}
     * @memberof AlbumsCreateBody
     */
    type: AlbumsCreateBody.TypeEnum;
}

/**
 * @export
 * @namespace AlbumsCreateBody
 */
export namespace AlbumsCreateBody {
    /**
     * @export
     * @enum {string}
     */
    export enum IsPublicEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Artwork = <any> 'artwork',
        Comic = <any> 'comic',
        Tutorial = <any> 'tutorial'
    }
}
/**
 * 
 * @export
 * @interface ArtworkAssetsModel
 */
export interface ArtworkAssetsModel {
    /**
     * 
     * @type {number}
     * @memberof ArtworkAssetsModel
     */
    workId?: number;
    /**
     * 
     * @type {string}
     * @memberof ArtworkAssetsModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkAssetsModel
     */
    driver?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkAssetsModel
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkAssetsModel
     */
    b2FileId?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkAssetsModel
     */
    filename?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtworkAssetsModel
     */
    fileOrder?: number;
}
/**
 * 
 * @export
 */
export type ArtworkHasTagsModel = Array<ArtworkHasTagsModelInner>
/**
 * 
 * @export
 * @interface ArtworkHasTagsModelInner
 */
export interface ArtworkHasTagsModelInner {
    /**
     * 
     * @type {any}
     * @memberof ArtworkHasTagsModelInner
     */
    artworkTags?: any;
}
/**
 * 
 * @export
 * @interface ArtworkLiteModel
 */
export interface ArtworkLiteModel {
    /**
     * 
     * @type {number}
     * @memberof ArtworkLiteModel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ArtworkLiteModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkLiteModel
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtworkLiteModel
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkLiteModel
     */
    isExplicit?: ArtworkLiteModel.IsExplicitEnum;
    /**
     * 
     * @type {string}
     * @memberof ArtworkLiteModel
     */
    scheduledPost?: string;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof ArtworkLiteModel
     */
    users?: UserLiteModel;
    /**
     * 
     * @type {Array<ArtworkAssetsModel>}
     * @memberof ArtworkLiteModel
     */
    artworkAssets?: Array<ArtworkAssetsModel>;
    /**
     * 
     * @type {boolean}
     * @memberof ArtworkLiteModel
     */
    liked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ArtworkLiteModel
     */
    saved?: boolean;
    /**
     * 
     * @type {ArtworkLiteModelCount}
     * @memberof ArtworkLiteModel
     */
    count?: ArtworkLiteModelCount;
}

/**
 * @export
 * @namespace ArtworkLiteModel
 */
export namespace ArtworkLiteModel {
    /**
     * @export
     * @enum {string}
     */
    export enum IsExplicitEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface ArtworkLiteModelCount
 */
export interface ArtworkLiteModelCount {
    /**
     * 
     * @type {number}
     * @memberof ArtworkLiteModelCount
     */
    artworkAssets?: number;
}
/**
 * 
 * @export
 * @interface ArtworkModel
 */
export interface ArtworkModel extends ArtworkLiteModel {
    /**
     * 
     * @type {string}
     * @memberof ArtworkModel
     */
    createdAt?: string;
    /**
     * 
     * @type {ArtworkHasTagsModel}
     * @memberof ArtworkModel
     */
    artworkHasTags?: ArtworkHasTagsModel;
    /**
     * 
     * @type {ArtworkModelCount}
     * @memberof ArtworkModel
     */
    count?: ArtworkModelCount;
    /**
     * 
     * @type {boolean}
     * @memberof ArtworkModel
     */
    liked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ArtworkModel
     */
    saved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ArtworkModel
     */
    inAlbum?: boolean;
}

/**
 * @export
 * @namespace ArtworkModel
 */
export namespace ArtworkModel {
}
/**
 * 
 * @export
 * @interface ArtworkModelCount
 */
export interface ArtworkModelCount {
    /**
     * 
     * @type {number}
     * @memberof ArtworkModelCount
     */
    artworkAssets?: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkModelCount
     */
    artworkComments?: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkModelCount
     */
    artworkLikes?: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkModelCount
     */
    collectionHasArtworks?: number;
}
/**
 * 
 * @export
 */
export type ArtworkViewsModel = Array<ArtworkViewsModelInner>
/**
 * 
 * @export
 * @interface ArtworkViewsModelInner
 */
export interface ArtworkViewsModelInner {
    /**
     * 
     * @type {number}
     * @memberof ArtworkViewsModelInner
     */
    workId?: number;
    /**
     * 
     * @type {string}
     * @memberof ArtworkViewsModelInner
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtworkViewsModelInner
     */
    views?: number;
}
/**
 * 
 * @export
 * @interface ArtworksBody
 */
export interface ArtworksBody {
    /**
     * 
     * @type {number}
     * @memberof ArtworksBody
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ArtworksBody
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworksBody
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtworksBody
     */
    isExplicit?: ArtworksBody.IsExplicitEnum;
    /**
     * 
     * @type {string}
     * @memberof ArtworksBody
     */
    scheduledPost?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworksBody
     */
    tags?: string;
}

/**
 * @export
 * @namespace ArtworksBody
 */
export namespace ArtworksBody {
    /**
     * @export
     * @enum {string}
     */
    export enum IsExplicitEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface ArtworksCommentsBody
 */
export interface ArtworksCommentsBody {
    /**
     * 
     * @type {number}
     * @memberof ArtworksCommentsBody
     */
    workId: number;
    /**
     * 
     * @type {string}
     * @memberof ArtworksCommentsBody
     */
    comment: string;
}
/**
 * 
 * @export
 * @interface ArtworksLikeBody
 */
export interface ArtworksLikeBody {
    /**
     * 
     * @type {number}
     * @memberof ArtworksLikeBody
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ArtworksPostBody
 */
export interface ArtworksPostBody {
    /**
     * 
     * @type {string}
     * @memberof ArtworksPostBody
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworksPostBody
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworksPostBody
     */
    tags?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtworksPostBody
     */
    isExplicit?: ArtworksPostBody.IsExplicitEnum;
    /**
     * 
     * @type {string}
     * @memberof ArtworksPostBody
     */
    scheduledPost?: string;
    /**
     * 
     * @type {Array<Blob>}
     * @memberof ArtworksPostBody
     */
    files?: Array<Blob>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ArtworksPostBody
     */
    fileOrder?: Array<number>;
}

/**
 * @export
 * @namespace ArtworksPostBody
 */
export namespace ArtworksPostBody {
    /**
     * @export
     * @enum {string}
     */
    export enum IsExplicitEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface ArtworksUnlikeBody
 */
export interface ArtworksUnlikeBody {
    /**
     * 
     * @type {number}
     * @memberof ArtworksUnlikeBody
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AuthAuthenticateBody
 */
export interface AuthAuthenticateBody {
    /**
     * 
     * @type {string}
     * @memberof AuthAuthenticateBody
     */
    emailUsername?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthAuthenticateBody
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface AuthRefreshBody
 */
export interface AuthRefreshBody {
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshBody
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface CheckEmailBody
 */
export interface CheckEmailBody {
    /**
     * 
     * @type {string}
     * @memberof CheckEmailBody
     */
    email: string;
}
/**
 * 
 * @export
 * @interface CheckUsernameBody
 */
export interface CheckUsernameBody {
    /**
     * 
     * @type {string}
     * @memberof CheckUsernameBody
     */
    username: string;
}
/**
 * 
 * @export
 * @interface CollectionHasArtworksModel
 */
export interface CollectionHasArtworksModel {
    /**
     * 
     * @type {ArtworkLiteModel}
     * @memberof CollectionHasArtworksModel
     */
    artworks?: ArtworkLiteModel;
}
/**
 * 
 * @export
 * @interface CollectionIdItemsBody
 */
export interface CollectionIdItemsBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof CollectionIdItemsBody
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface CollectionIdItemsBody1
 */
export interface CollectionIdItemsBody1 {
    /**
     * 
     * @type {Array<number>}
     * @memberof CollectionIdItemsBody1
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface CollectionModel
 */
export interface CollectionModel {
    /**
     * 
     * @type {number}
     * @memberof CollectionModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionModel
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionModel
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionModel
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionModel
     */
    isPublic?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionModel
     */
    isEditable?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionModel
     */
    createdAt?: string;
    /**
     * 
     * @type {CollectionModelCount}
     * @memberof CollectionModel
     */
    count?: CollectionModelCount;
    /**
     * 
     * @type {Array<CollectionHasArtworksModel>}
     * @memberof CollectionModel
     */
    collectionHasArtworks?: Array<CollectionHasArtworksModel>;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof CollectionModel
     */
    users?: UserLiteModel;
}
/**
 * 
 * @export
 * @interface CollectionModelCount
 */
export interface CollectionModelCount {
    /**
     * 
     * @type {number}
     * @memberof CollectionModelCount
     */
    collectionHasArtworks?: number;
}
/**
 * 
 * @export
 * @interface CollectionsBody
 */
export interface CollectionsBody {
    /**
     * 
     * @type {number}
     * @memberof CollectionsBody
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionsBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionsBody
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionsBody
     */
    isPublic?: CollectionsBody.IsPublicEnum;
}

/**
 * @export
 * @namespace CollectionsBody
 */
export namespace CollectionsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum IsPublicEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface CollectionsCreateBody
 */
export interface CollectionsCreateBody {
    /**
     * 
     * @type {string}
     * @memberof CollectionsCreateBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionsCreateBody
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionsCreateBody
     */
    isPublic?: CollectionsCreateBody.IsPublicEnum;
    /**
     * 
     * @type {string}
     * @memberof CollectionsCreateBody
     */
    type?: CollectionsCreateBody.TypeEnum;
}

/**
 * @export
 * @namespace CollectionsCreateBody
 */
export namespace CollectionsCreateBody {
    /**
     * @export
     * @enum {string}
     */
    export enum IsPublicEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Artwork = <any> 'artwork',
        Comic = <any> 'comic',
        Tutorial = <any> 'tutorial'
    }
}
/**
 * 
 * @export
 * @interface CollectionsLaterBody
 */
export interface CollectionsLaterBody {
    /**
     * 
     * @type {Array<number>}
     * @memberof CollectionsLaterBody
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface CommentModel
 */
export interface CommentModel {
}
/**
 * 
 * @export
 * @interface CommentModelCount
 */
export interface CommentModelCount {
    /**
     * 
     * @type {number}
     * @memberof CommentModelCount
     */
    artworkCommentHasLikes?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentModelCount
     */
    artworkCommentHasReplies?: number;
}
/**
 * 
 * @export
 * @interface CommentsReplyBody
 */
export interface CommentsReplyBody {
    /**
     * 
     * @type {number}
     * @memberof CommentsReplyBody
     */
    commentId: number;
    /**
     * 
     * @type {string}
     * @memberof CommentsReplyBody
     */
    reply: string;
}
/**
 * 
 * @export
 * @interface CounterModel
 */
export interface CounterModel {
    /**
     * 
     * @type {boolean}
     * @memberof CounterModel
     */
    success?: boolean;
    /**
     * 
     * @type {CounterModelData}
     * @memberof CounterModel
     */
    data?: CounterModelData;
}
/**
 * 
 * @export
 * @interface CounterModelData
 */
export interface CounterModelData {
    /**
     * 
     * @type {number}
     * @memberof CounterModelData
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface CurrentCheckBody
 */
export interface CurrentCheckBody {
    /**
     * 
     * @type {number}
     * @memberof CurrentCheckBody
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentCheckBody
     */
    currentPassword: string;
}
/**
 * 
 * @export
 * @interface FeedCommentModel
 */
export interface FeedCommentModel {
    /**
     * 
     * @type {number}
     * @memberof FeedCommentModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedCommentModel
     */
    feedId?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedCommentModel
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedCommentModel
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof FeedCommentModel
     */
    isNotifExpanded?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedCommentModel
     */
    isRead?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedCommentModel
     */
    isCleared?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedCommentModel
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedCommentModel
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface FeedLiteModel
 */
export interface FeedLiteModel {
    /**
     * 
     * @type {number}
     * @memberof FeedLiteModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedLiteModel
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedLiteModel
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedLiteModel
     */
    visibility?: FeedLiteModel.VisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof FeedLiteModel
     */
    whoCanReply?: FeedLiteModel.WhoCanReplyEnum;
    /**
     * 
     * @type {number}
     * @memberof FeedLiteModel
     */
    workId?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedLiteModel
     */
    feedId?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedLiteModel
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof FeedLiteModel
     */
    updatedAt?: string;
}

/**
 * @export
 * @namespace FeedLiteModel
 */
export namespace FeedLiteModel {
    /**
     * @export
     * @enum {string}
     */
    export enum VisibilityEnum {
        Public = <any> 'public',
        Followers = <any> 'followers'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WhoCanReplyEnum {
        Public = <any> 'public',
        Followers = <any> 'followers'
    }
}
/**
 * 
 * @export
 * @interface FeedModel
 */
export interface FeedModel extends FeedLiteModel {
    /**
     * 
     * @type {UserLiteModel}
     * @memberof FeedModel
     */
    users?: UserLiteModel;
    /**
     * 
     * @type {Array<FeedModelFeedHasFiles>}
     * @memberof FeedModel
     */
    feedHasFiles?: Array<FeedModelFeedHasFiles>;
    /**
     * 
     * @type {any}
     * @memberof FeedModel
     */
    artworks?: any;
    /**
     * 
     * @type {FeedLiteModel}
     * @memberof FeedModel
     */
    feeds?: FeedLiteModel;
}

/**
 * @export
 * @namespace FeedModel
 */
export namespace FeedModel {
}
/**
 * 
 * @export
 * @interface FeedModelFeedHasFiles
 */
export interface FeedModelFeedHasFiles {
    /**
     * 
     * @type {string}
     * @memberof FeedModelFeedHasFiles
     */
    filename?: string;
}
/**
 * 
 * @export
 * @interface FeedsCommentBody
 */
export interface FeedsCommentBody {
    /**
     * 
     * @type {number}
     * @memberof FeedsCommentBody
     */
    feedId: number;
    /**
     * 
     * @type {string}
     * @memberof FeedsCommentBody
     */
    comment: string;
}
/**
 * 
 * @export
 * @interface FeedsCreateBody
 */
export interface FeedsCreateBody {
    /**
     * 
     * @type {number}
     * @memberof FeedsCreateBody
     */
    text: number;
    /**
     * 
     * @type {string}
     * @memberof FeedsCreateBody
     */
    visibility: FeedsCreateBody.VisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof FeedsCreateBody
     */
    whoCanReply: FeedsCreateBody.WhoCanReplyEnum;
    /**
     * 
     * @type {number}
     * @memberof FeedsCreateBody
     */
    workId?: number;
    /**
     * 
     * @type {number}
     * @memberof FeedsCreateBody
     */
    feedId?: number;
}

/**
 * @export
 * @namespace FeedsCreateBody
 */
export namespace FeedsCreateBody {
    /**
     * @export
     * @enum {string}
     */
    export enum VisibilityEnum {
        Public = <any> 'public',
        Followers = <any> 'followers'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WhoCanReplyEnum {
        Public = <any> 'public',
        Followers = <any> 'followers'
    }
}
/**
 * 
 * @export
 * @interface FeedsUpdateBody
 */
export interface FeedsUpdateBody {
    /**
     * 
     * @type {number}
     * @memberof FeedsUpdateBody
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof FeedsUpdateBody
     */
    text: number;
    /**
     * 
     * @type {string}
     * @memberof FeedsUpdateBody
     */
    visibility: FeedsUpdateBody.VisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof FeedsUpdateBody
     */
    whoCanReply: FeedsUpdateBody.WhoCanReplyEnum;
}

/**
 * @export
 * @namespace FeedsUpdateBody
 */
export namespace FeedsUpdateBody {
    /**
     * @export
     * @enum {string}
     */
    export enum VisibilityEnum {
        Public = <any> 'public',
        Followers = <any> 'followers'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WhoCanReplyEnum {
        Public = <any> 'public',
        Followers = <any> 'followers'
    }
}
/**
 * 
 * @export
 */
export type FollowingArtworkCommentsModel = Array<FollowingArtworkCommentsModelInner>
/**
 * 
 * @export
 * @interface FollowingArtworkCommentsModelInner
 */
export interface FollowingArtworkCommentsModelInner {
    /**
     * 
     * @type {number}
     * @memberof FollowingArtworkCommentsModelInner
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FollowingArtworkCommentsModelInner
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowingArtworkCommentsModelInner
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowingArtworkCommentsModelInner
     */
    updatedAt?: string;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof FollowingArtworkCommentsModelInner
     */
    users?: UserLiteModel;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 extends SuccessMessageModel {
    /**
     * 
     * @type {InlineResponse200Data}
     * @memberof InlineResponse200
     */
    data?: InlineResponse200Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 extends SuccessMessageModel {
    /**
     * 
     * @type {InlineResponse2001Data}
     * @memberof InlineResponse2001
     */
    data?: InlineResponse2001Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20010
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20010Data}
     * @memberof InlineResponse20010
     */
    data?: InlineResponse20010Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Data
 */
export interface InlineResponse20010Data {
    /**
     * 
     * @type {Array<CollectionModel>}
     * @memberof InlineResponse20010Data
     */
    collections?: Array<CollectionModel>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20011
     */
    success?: boolean;
    /**
     * 
     * @type {Array<InlineResponse20011Data>}
     * @memberof InlineResponse20011
     */
    data?: Array<InlineResponse20011Data>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Data
 */
export interface InlineResponse20011Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011Data
     */
    collectionId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011Data
     */
    workId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Data
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20012
     */
    success?: boolean;
    /**
     * 
     * @type {CounterModelData}
     * @memberof InlineResponse20012
     */
    data?: CounterModelData;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20013
     */
    success?: boolean;
    /**
     * 
     * @type {Array<InlineResponse20013Data>}
     * @memberof InlineResponse20013
     */
    data?: Array<InlineResponse20013Data>;
}
/**
 * 
 * @export
 * @interface InlineResponse20013Data
 */
export interface InlineResponse20013Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20013Data
     */
    albumId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20013Data
     */
    workId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013Data
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20014
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20014Data}
     * @memberof InlineResponse20014
     */
    data?: InlineResponse20014Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20014Data
 */
export interface InlineResponse20014Data {
    /**
     * 
     * @type {Array<ArtworkLiteModel>}
     * @memberof InlineResponse20014Data
     */
    works?: Array<ArtworkLiteModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20014Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20015Data}
     * @memberof InlineResponse20015
     */
    data?: InlineResponse20015Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Data
 */
export interface InlineResponse20015Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Data
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20016Data}
     * @memberof InlineResponse20016
     */
    data?: InlineResponse20016Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20016Data
 */
export interface InlineResponse20016Data {
    /**
     * 
     * @type {Array<AlbumHasArtworksModelArtworkAlbumHasWorks>}
     * @memberof InlineResponse20016Data
     */
    works?: Array<AlbumHasArtworksModelArtworkAlbumHasWorks>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20016Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20017
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20017Data}
     * @memberof InlineResponse20017
     */
    data?: InlineResponse20017Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20017Data
 */
export interface InlineResponse20017Data {
    /**
     * 
     * @type {Array<AlbumModel>}
     * @memberof InlineResponse20017Data
     */
    albums?: Array<AlbumModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20017Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20018
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20018Data}
     * @memberof InlineResponse20018
     */
    data?: InlineResponse20018Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20018Data
 */
export interface InlineResponse20018Data {
    /**
     * 
     * @type {Array<CommentModel>}
     * @memberof InlineResponse20018Data
     */
    comments?: Array<CommentModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20018Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20019
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20019Data}
     * @memberof InlineResponse20019
     */
    data?: InlineResponse20019Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20019Data
 */
export interface InlineResponse20019Data {
    /**
     * 
     * @type {Array<ReplyModel & any>}
     * @memberof InlineResponse20019Data
     */
    replies?: Array<ReplyModel & any>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20019Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse2001Data
 */
export interface InlineResponse2001Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse2002Data}
     * @memberof InlineResponse2002
     */
    data?: InlineResponse2002Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 extends SuccessMessageModel {
    /**
     * 
     * @type {InlineResponse20020Data}
     * @memberof InlineResponse20020
     */
    data?: InlineResponse20020Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20020Data
 */
export interface InlineResponse20020Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20020Data
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20020Data
     */
    commentId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020Data
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20021
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20021Data}
     * @memberof InlineResponse20021
     */
    data?: InlineResponse20021Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20021Data
 */
export interface InlineResponse20021Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20021Data
     */
    views?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20022
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20014Data}
     * @memberof InlineResponse20022
     */
    data?: InlineResponse20014Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20023
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20023
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20024
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20024Data}
     * @memberof InlineResponse20024
     */
    data?: InlineResponse20024Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20024Data
 */
export interface InlineResponse20024Data {
    /**
     * 
     * @type {Array<InlineResponse20024DataTags>}
     * @memberof InlineResponse20024Data
     */
    tags?: Array<InlineResponse20024DataTags>;
}
/**
 * 
 * @export
 * @interface InlineResponse20024DataTags
 */
export interface InlineResponse20024DataTags {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataTags
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataTags
     */
    tag?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20025
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20025Data}
     * @memberof InlineResponse20025
     */
    data?: InlineResponse20025Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20025Data
 */
export interface InlineResponse20025Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20025Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20026
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20026Data}
     * @memberof InlineResponse20026
     */
    data?: InlineResponse20026Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20026Data
 */
export interface InlineResponse20026Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Data
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20027
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20027Data}
     * @memberof InlineResponse20027
     */
    data?: InlineResponse20027Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20027Data
 */
export interface InlineResponse20027Data {
    /**
     * 
     * @type {Array<UserModel & any>}
     * @memberof InlineResponse20027Data
     */
    users?: Array<UserModel & any>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20027Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20028
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20028Data}
     * @memberof InlineResponse20028
     */
    data?: InlineResponse20028Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20028Data
 */
export interface InlineResponse20028Data {
    /**
     * 
     * @type {Array<InlineResponse20028DataNotifications>}
     * @memberof InlineResponse20028Data
     */
    notifications?: Array<InlineResponse20028DataNotifications>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20028Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20028DataNotifications
 */
export interface InlineResponse20028DataNotifications {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028DataNotifications
     */
    workId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028DataNotifications
     */
    isRead?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028DataNotifications
     */
    driver?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028DataNotifications
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028DataNotifications
     */
    b2FileId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028DataNotifications
     */
    filename?: string;
    /**
     * 
     * @type {Array<InlineResponse20028DataUserLiked>}
     * @memberof InlineResponse20028DataNotifications
     */
    userLiked?: Array<InlineResponse20028DataUserLiked>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028DataNotifications
     */
    totalLiked?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028DataNotifications
     */
    restTotalLiked?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028DataNotifications
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20028DataUserLiked
 */
export interface InlineResponse20028DataUserLiked {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028DataUserLiked
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028DataUserLiked
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028DataUserLiked
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20029
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20029
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Data
 */
export interface InlineResponse2002Data {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002Data
     */
    valid?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    success?: boolean;
    /**
     * 
     * @type {UserAllModel}
     * @memberof InlineResponse2003
     */
    data?: UserAllModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20030
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20030Data}
     * @memberof InlineResponse20030
     */
    data?: InlineResponse20030Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20030Data
 */
export interface InlineResponse20030Data {
    /**
     * 
     * @type {Array<InlineResponse20030DataNotifications>}
     * @memberof InlineResponse20030Data
     */
    notifications?: Array<InlineResponse20030DataNotifications>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20030Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20030DataArtworks
 */
export interface InlineResponse20030DataArtworks {
    /**
     * 
     * @type {Array<InlineResponse20030DataArtworksArtworkAssets>}
     * @memberof InlineResponse20030DataArtworks
     */
    artworkAssets?: Array<InlineResponse20030DataArtworksArtworkAssets>;
}
/**
 * 
 * @export
 * @interface InlineResponse20030DataArtworksArtworkAssets
 */
export interface InlineResponse20030DataArtworksArtworkAssets {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataArtworksArtworkAssets
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataArtworksArtworkAssets
     */
    filename?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20030DataNotifications
 */
export interface InlineResponse20030DataNotifications {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030DataNotifications
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030DataNotifications
     */
    workId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataNotifications
     */
    comment?: string;
    /**
     * 
     * @type {InlineResponse20030DataUsers}
     * @memberof InlineResponse20030DataNotifications
     */
    users?: InlineResponse20030DataUsers;
    /**
     * 
     * @type {InlineResponse20030DataArtworks}
     * @memberof InlineResponse20030DataNotifications
     */
    artworks?: InlineResponse20030DataArtworks;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataNotifications
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20030DataUsers
 */
export interface InlineResponse20030DataUsers {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataUsers
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataUsers
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataUsers
     */
    avatarBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030DataUsers
     */
    avatarFilename?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20031
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20031Data}
     * @memberof InlineResponse20031
     */
    data?: InlineResponse20031Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20031Data
 */
export interface InlineResponse20031Data {
    /**
     * 
     * @type {Array<InlineResponse20031DataNotifications>}
     * @memberof InlineResponse20031Data
     */
    notifications?: Array<InlineResponse20031DataNotifications>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20031Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20031DataArtworks
 */
export interface InlineResponse20031DataArtworks {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031DataArtworks
     */
    id?: number;
    /**
     * 
     * @type {InlineResponse20030DataArtworksArtworkAssets}
     * @memberof InlineResponse20031DataArtworks
     */
    assets?: InlineResponse20030DataArtworksArtworkAssets;
}
/**
 * 
 * @export
 * @interface InlineResponse20031DataNotifications
 */
export interface InlineResponse20031DataNotifications {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031DataNotifications
     */
    commentId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031DataNotifications
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031DataNotifications
     */
    isRead?: number;
    /**
     * 
     * @type {Array<InlineResponse20031DataUserLiked>}
     * @memberof InlineResponse20031DataNotifications
     */
    userLiked?: Array<InlineResponse20031DataUserLiked>;
    /**
     * 
     * @type {InlineResponse20031DataArtworks}
     * @memberof InlineResponse20031DataNotifications
     */
    artworks?: InlineResponse20031DataArtworks;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031DataNotifications
     */
    totalLiked?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031DataNotifications
     */
    restTotalLiked?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031DataNotifications
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20031DataUserLiked
 */
export interface InlineResponse20031DataUserLiked {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031DataUserLiked
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031DataUserLiked
     */
    avatarBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031DataUserLiked
     */
    avatarFilename?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20032
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20032Data}
     * @memberof InlineResponse20032
     */
    data?: InlineResponse20032Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20032Data
 */
export interface InlineResponse20032Data {
    /**
     * 
     * @type {Array<InlineResponse20032DataNotifications>}
     * @memberof InlineResponse20032Data
     */
    notifications?: Array<InlineResponse20032DataNotifications>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20032Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20032DataNotifications
 */
export interface InlineResponse20032DataNotifications {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032DataNotifications
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032DataNotifications
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032DataNotifications
     */
    commentId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032DataNotifications
     */
    comment?: string;
    /**
     * 
     * @type {Array<InlineResponse20028DataUserLiked>}
     * @memberof InlineResponse20032DataNotifications
     */
    userReplied?: Array<InlineResponse20028DataUserLiked>;
    /**
     * 
     * @type {InlineResponse20031DataArtworks}
     * @memberof InlineResponse20032DataNotifications
     */
    artworks?: InlineResponse20031DataArtworks;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032DataNotifications
     */
    totalLiked?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032DataNotifications
     */
    restTotalLiked?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032DataNotifications
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20033
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20033Data}
     * @memberof InlineResponse20033
     */
    data?: InlineResponse20033Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20033Data
 */
export interface InlineResponse20033Data {
    /**
     * 
     * @type {Array<InlineResponse20033DataNotifications>}
     * @memberof InlineResponse20033Data
     */
    notifications?: Array<InlineResponse20033DataNotifications>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20033Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20033DataNotifications
 */
export interface InlineResponse20033DataNotifications {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20033DataNotifications
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DataNotifications
     */
    content?: string;
    /**
     * 
     * @type {Array<InlineResponse20028DataUserLiked>}
     * @memberof InlineResponse20033DataNotifications
     */
    userLiked?: Array<InlineResponse20028DataUserLiked>;
    /**
     * 
     * @type {InlineResponse20031DataArtworks}
     * @memberof InlineResponse20033DataNotifications
     */
    artworks?: InlineResponse20031DataArtworks;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20033DataNotifications
     */
    totalLiked?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20033DataNotifications
     */
    restTotalLiked?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033DataNotifications
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20034
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20034Data}
     * @memberof InlineResponse20034
     */
    data?: InlineResponse20034Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20034Data
 */
export interface InlineResponse20034Data {
    /**
     * 
     * @type {Array<InlineResponse20034DataNotifications>}
     * @memberof InlineResponse20034Data
     */
    notifications?: Array<InlineResponse20034DataNotifications>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20034Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20034DataFollowerDetail
 */
export interface InlineResponse20034DataFollowerDetail {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20034DataFollowerDetail
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034DataFollowerDetail
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034DataFollowerDetail
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034DataFollowerDetail
     */
    avatarBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034DataFollowerDetail
     */
    avatarFilename?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20034DataNotifications
 */
export interface InlineResponse20034DataNotifications {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20034DataNotifications
     */
    isRead?: number;
    /**
     * 
     * @type {Array<InlineResponse20034DataFollowerDetail>}
     * @memberof InlineResponse20034DataNotifications
     */
    followerDetail?: Array<InlineResponse20034DataFollowerDetail>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034DataNotifications
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20035
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20035Data}
     * @memberof InlineResponse20035
     */
    data?: InlineResponse20035Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20035Data
 */
export interface InlineResponse20035Data {
    /**
     * 
     * @type {InlineResponse20035DataNotifications}
     * @memberof InlineResponse20035Data
     */
    notifications?: InlineResponse20035DataNotifications;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20035Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20035DataNotifications
 */
export interface InlineResponse20035DataNotifications {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20035DataNotifications
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035DataNotifications
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035DataNotifications
     */
    comment?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20035DataNotifications
     */
    isRead?: boolean;
    /**
     * 
     * @type {Array<InlineResponse20034DataFollowerDetail>}
     * @memberof InlineResponse20035DataNotifications
     */
    users?: Array<InlineResponse20034DataFollowerDetail>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20035DataNotifications
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20035DataNotifications
     */
    restTotal?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035DataNotifications
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035DataNotifications
     */
    type?: InlineResponse20035DataNotifications.TypeEnum;
}

/**
 * @export
 * @namespace InlineResponse20035DataNotifications
 */
export namespace InlineResponse20035DataNotifications {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Like = <any> 'like',
        Comment = <any> 'comment'
    }
}
/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20036
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20036Data}
     * @memberof InlineResponse20036
     */
    data?: InlineResponse20036Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20036Data
 */
export interface InlineResponse20036Data {
    /**
     * 
     * @type {Array<FeedModel>}
     * @memberof InlineResponse20036Data
     */
    feeds?: Array<FeedModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20036Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20037
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20037Data}
     * @memberof InlineResponse20037
     */
    data?: InlineResponse20037Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20037Data
 */
export interface InlineResponse20037Data {
    /**
     * 
     * @type {Array<FeedCommentModel>}
     * @memberof InlineResponse20037Data
     */
    comments?: Array<FeedCommentModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20037Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20038
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20038Data}
     * @memberof InlineResponse20038
     */
    data?: InlineResponse20038Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20038Data
 */
export interface InlineResponse20038Data {
    /**
     * 
     * @type {Array<ArtworkLiteModel>}
     * @memberof InlineResponse20038Data
     */
    feeds?: Array<ArtworkLiteModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20038Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20039
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20039Feed}
     * @memberof InlineResponse20039
     */
    feed?: InlineResponse20039Feed;
}
/**
 * 
 * @export
 * @interface InlineResponse20039Feed
 */
export interface InlineResponse20039Feed {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    text?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    visibility?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    whoCanReply?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    workId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    feedId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    createdAt?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    updatedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    feedHasFiles?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    artworks?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039Feed
     */
    feeds?: number;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof InlineResponse20039Feed
     */
    users?: UserLiteModel;
    /**
     * 
     * @type {InlineResponse20039FeedCount}
     * @memberof InlineResponse20039Feed
     */
    count?: InlineResponse20039FeedCount;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20039Feed
     */
    liked?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20039FeedCount
 */
export interface InlineResponse20039FeedCount {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039FeedCount
     */
    feedComments?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039FeedCount
     */
    feedLikes?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 extends SuccessMessageModel {
    /**
     * 
     * @type {InlineResponse2004Data}
     * @memberof InlineResponse2004
     */
    data?: InlineResponse2004Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20040
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20040Data}
     * @memberof InlineResponse20040
     */
    data?: InlineResponse20040Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20040Data
 */
export interface InlineResponse20040Data {
    /**
     * 
     * @type {Array<ReportModel>}
     * @memberof InlineResponse20040Data
     */
    reports?: Array<ReportModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse20040Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20041
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse20041Data}
     * @memberof InlineResponse20041
     */
    data?: InlineResponse20041Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20041Data
 */
export interface InlineResponse20041Data {
    /**
     * 
     * @type {InlineResponse20041DataReport}
     * @memberof InlineResponse20041Data
     */
    report?: InlineResponse20041DataReport;
}
/**
 * 
 * @export
 * @interface InlineResponse20041DataReport
 */
export interface InlineResponse20041DataReport {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20041DataReport
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041DataReport
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Data
 */
export interface InlineResponse2004Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    avatar?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 extends SuccessMessageModel {
    /**
     * 
     * @type {InlineResponse2005Data}
     * @memberof InlineResponse2005
     */
    data?: InlineResponse2005Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2005Data
 */
export interface InlineResponse2005Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Data
     */
    cover?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse2006Data}
     * @memberof InlineResponse2006
     */
    data?: InlineResponse2006Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Data
 */
export interface InlineResponse2006Data {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006Data
     */
    isFollowing?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2007
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse2007Data}
     * @memberof InlineResponse2007
     */
    data?: InlineResponse2007Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2007Data
 */
export interface InlineResponse2007Data {
    /**
     * 
     * @type {InlineResponse2007DataData}
     * @memberof InlineResponse2007Data
     */
    data?: InlineResponse2007DataData;
}
/**
 * 
 * @export
 * @interface InlineResponse2007DataData
 */
export interface InlineResponse2007DataData {
    /**
     * 
     * @type {Array<UserLiteModel & any>}
     * @memberof InlineResponse2007DataData
     */
    followings?: Array<UserLiteModel & any>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse2007DataData
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse2008Data}
     * @memberof InlineResponse2008
     */
    data?: InlineResponse2008Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2008Data
 */
export interface InlineResponse2008Data {
    /**
     * 
     * @type {InlineResponse2008DataData}
     * @memberof InlineResponse2008Data
     */
    data?: InlineResponse2008DataData;
}
/**
 * 
 * @export
 * @interface InlineResponse2008DataData
 */
export interface InlineResponse2008DataData {
    /**
     * 
     * @type {Array<UserLiteModel & any>}
     * @memberof InlineResponse2008DataData
     */
    followers?: Array<UserLiteModel & any>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse2008DataData
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2009
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse2009
     */
    data?: InlineResponse2009Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2009Data
 */
export interface InlineResponse2009Data {
    /**
     * 
     * @type {Array<CollectionHasArtworksModel>}
     * @memberof InlineResponse2009Data
     */
    items?: Array<CollectionHasArtworksModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof InlineResponse2009Data
     */
    pagination?: PaginationModel;
}
/**
 * 
 * @export
 * @interface InlineResponse200Data
 */
export interface InlineResponse200Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Data
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Data
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 extends SuccessMessageModel {
    /**
     * 
     * @type {CollectionModel}
     * @memberof InlineResponse201
     */
    data?: CollectionModel;
}
/**
 * 
 * @export
 * @interface InlineResponse2011
 */
export interface InlineResponse2011 extends SuccessMessageModel {
    /**
     * 
     * @type {InlineResponse2011Data}
     * @memberof InlineResponse2011
     */
    data?: InlineResponse2011Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2011Data
 */
export interface InlineResponse2011Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2011Data
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2011Data
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2011Data
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2011Data
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2011Data
     */
    isExplicit?: InlineResponse2011Data.IsExplicitEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2011Data
     */
    scheduledPost?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2011Data
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2011Data
     */
    updatedAt?: string;
}

/**
 * @export
 * @namespace InlineResponse2011Data
 */
export namespace InlineResponse2011Data {
    /**
     * @export
     * @enum {string}
     */
    export enum IsExplicitEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface InlineResponse2012
 */
export interface InlineResponse2012 extends SuccessMessageModel {
    /**
     * 
     * @type {InlineResponse2012Data}
     * @memberof InlineResponse2012
     */
    data?: InlineResponse2012Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2012Data
 */
export interface InlineResponse2012Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2012Data
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2012Data
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2012Data
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2012Data
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2012Data
     */
    isPublic?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2012Data
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2013
 */
export interface InlineResponse2013 extends SuccessMessageModel {
    /**
     * 
     * @type {CommentModel}
     * @memberof InlineResponse2013
     */
    data?: CommentModel;
}
/**
 * 
 * @export
 * @interface InlineResponse2014
 */
export interface InlineResponse2014 extends SuccessMessageModel {
    /**
     * 
     * @type {ReplyModel & any}
     * @memberof InlineResponse2014
     */
    data?: ReplyModel & any;
}
/**
 * 
 * @export
 * @interface InlineResponse2015
 */
export interface InlineResponse2015 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2015
     */
    success?: boolean;
    /**
     * 
     * @type {FeedLiteModel}
     * @memberof InlineResponse2015
     */
    data?: FeedLiteModel;
}
/**
 * 
 * @export
 * @interface InlineResponse2016
 */
export interface InlineResponse2016 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2016
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2016
     */
    message?: string;
    /**
     * 
     * @type {InlineResponse2016Data}
     * @memberof InlineResponse2016
     */
    data?: InlineResponse2016Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2016Data
 */
export interface InlineResponse2016Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2016Data
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2016Data
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2016Data
     */
    createdAt?: string;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof InlineResponse2016Data
     */
    users?: UserLiteModel;
}
/**
 * 
 * @export
 * @interface InlineResponse2017
 */
export interface InlineResponse2017 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2017
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse2017Data}
     * @memberof InlineResponse2017
     */
    data?: InlineResponse2017Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2017Data
 */
export interface InlineResponse2017Data {
    /**
     * 
     * @type {ReportModel}
     * @memberof InlineResponse2017Data
     */
    report?: ReportModel;
}
/**
 * 
 * @export
 * @interface PaginationModel
 */
export interface PaginationModel {
    /**
     * 
     * @type {number}
     * @memberof PaginationModel
     */
    recordTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationModel
     */
    totalPage?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationModel
     */
    currentPage?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationModel
     */
    perPage?: number;
    /**
     * 
     * @type {PaginationModelNextPrevious}
     * @memberof PaginationModel
     */
    nextPrevious?: PaginationModelNextPrevious;
    /**
     * 
     * @type {PaginationModelFirstLast}
     * @memberof PaginationModel
     */
    firstLast?: PaginationModelFirstLast;
}
/**
 * 
 * @export
 * @interface PaginationModelFirstLast
 */
export interface PaginationModelFirstLast {
    /**
     * 
     * @type {number}
     * @memberof PaginationModelFirstLast
     */
    firstPage?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationModelFirstLast
     */
    lastPage?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationModelFirstLast
     */
    firstPageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationModelFirstLast
     */
    lastPageUrl?: string;
}
/**
 * 
 * @export
 * @interface PaginationModelNextPrevious
 */
export interface PaginationModelNextPrevious {
    /**
     * 
     * @type {number}
     * @memberof PaginationModelNextPrevious
     */
    nextPage?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationModelNextPrevious
     */
    prevPage?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationModelNextPrevious
     */
    nextPageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationModelNextPrevious
     */
    prevPageUrl?: string;
}
/**
 * 
 * @export
 * @interface PasswordForgotBody
 */
export interface PasswordForgotBody {
    /**
     * 
     * @type {string}
     * @memberof PasswordForgotBody
     */
    email: string;
}
/**
 * 
 * @export
 * @interface PasswordRenewBody
 */
export interface PasswordRenewBody {
    /**
     * 
     * @type {number}
     * @memberof PasswordRenewBody
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof PasswordRenewBody
     */
    currentPassword: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordRenewBody
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface RecoverChangeBody
 */
export interface RecoverChangeBody {
    /**
     * Iv token obtained from url
     * @type {string}
     * @memberof RecoverChangeBody
     */
    iv: string;
    /**
     * Content token obtained from url
     * @type {string}
     * @memberof RecoverChangeBody
     */
    content: string;
    /**
     * The new password
     * @type {string}
     * @memberof RecoverChangeBody
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface RegistrationRegisterBody
 */
export interface RegistrationRegisterBody {
    /**
     * 
     * @type {string}
     * @memberof RegistrationRegisterBody
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRegisterBody
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRegisterBody
     */
    name: string;
    /**
     * User gender, pick either m or f
     * @type {string}
     * @memberof RegistrationRegisterBody
     */
    gender: RegistrationRegisterBody.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRegisterBody
     */
    password: string;
}

/**
 * @export
 * @namespace RegistrationRegisterBody
 */
export namespace RegistrationRegisterBody {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        M = <any> 'm',
        F = <any> 'f'
    }
}
/**
 * 
 * @export
 * @interface RegistrationResendverificationBody
 */
export interface RegistrationResendverificationBody {
    /**
     * 
     * @type {string}
     * @memberof RegistrationResendverificationBody
     */
    email: string;
}
/**
 * 
 * @export
 * @interface ReplyModel
 */
export interface ReplyModel {
    /**
     * 
     * @type {number}
     * @memberof ReplyModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplyModel
     */
    commentId?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplyModel
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof ReplyModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof ReplyModel
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ReplyModel
     */
    updatedAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReplyModel
     */
    liked?: boolean;
    /**
     * 
     * @type {ReplyModelCount}
     * @memberof ReplyModel
     */
    count?: ReplyModelCount;
}
/**
 * 
 * @export
 * @interface ReplyModelCount
 */
export interface ReplyModelCount {
    /**
     * 
     * @type {number}
     * @memberof ReplyModelCount
     */
    artworkCommentReplyHasLikes?: number;
}
/**
 * 
 * @export
 * @interface ReportModel
 */
export interface ReportModel {
    /**
     * 
     * @type {number}
     * @memberof ReportModel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    type?: ReportModel.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ReportModel
     */
    postId?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    reasons?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    response?: ReportModel.ResponseEnum;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    status?: ReportModel.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    responseDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportModel
     */
    respondedAt?: string;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof ReportModel
     */
    userReported?: UserLiteModel;
    /**
     * 
     * @type {UserLiteModel}
     * @memberof ReportModel
     */
    userResponded?: UserLiteModel;
}

/**
 * @export
 * @namespace ReportModel
 */
export namespace ReportModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Artwork = <any> 'artwork',
        Feed = <any> 'feed',
        Comment = <any> 'comment',
        CommentReply = <any> 'comment_reply'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResponseEnum {
        _0 = <any> '0',
        _1 = <any> '1'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Pending = <any> 'pending',
        Closed = <any> 'closed'
    }
}
/**
 * 
 * @export
 * @interface ReportsBody
 */
export interface ReportsBody {
    /**
     * 
     * @type {string}
     * @memberof ReportsBody
     */
    type: string;
    /**
     * 
     * @type {number}
     * @memberof ReportsBody
     */
    postId: number;
    /**
     * 
     * @type {string}
     * @memberof ReportsBody
     */
    reasons: string;
    /**
     * 
     * @type {string}
     * @memberof ReportsBody
     */
    description: string;
}
/**
 * 
 * @export
 * @interface ReportsReviewBody
 */
export interface ReportsReviewBody {
    /**
     * 
     * @type {number}
     * @memberof ReportsReviewBody
     */
    reportId: number;
    /**
     * 
     * @type {string}
     * @memberof ReportsReviewBody
     */
    response: string;
    /**
     * 
     * @type {string}
     * @memberof ReportsReviewBody
     */
    responseDescription: string;
}
/**
 * 
 * @export
 * @interface SuccessMessageModel
 */
export interface SuccessMessageModel {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessMessageModel
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SuccessMessageModel
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface UpdateAvatarBody
 */
export interface UpdateAvatarBody {
    /**
     * 
     * @type {Blob}
     * @memberof UpdateAvatarBody
     */
    avatar?: Blob;
}
/**
 * 
 * @export
 * @interface UpdateCoverBody
 */
export interface UpdateCoverBody {
    /**
     * 
     * @type {Blob}
     * @memberof UpdateCoverBody
     */
    cover?: Blob;
}
/**
 * 
 * @export
 * @interface UpdateInfoBody
 */
export interface UpdateInfoBody {
    /**
     * 
     * @type {number}
     * @memberof UpdateInfoBody
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateInfoBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInfoBody
     */
    gender?: UpdateInfoBody.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateInfoBody
     */
    bio?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInfoBody
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateInfoBody
     */
    penName?: string;
}

/**
 * @export
 * @namespace UpdateInfoBody
 */
export namespace UpdateInfoBody {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        M = <any> 'm',
        F = <any> 'f'
    }
}
/**
 * 
 * @export
 * @interface UpdatePreferenceBody
 */
export interface UpdatePreferenceBody {
    /**
     * 
     * @type {number}
     * @memberof UpdatePreferenceBody
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePreferenceBody
     */
    language?: UpdatePreferenceBody.LanguageEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdatePreferenceBody
     */
    darkMode?: UpdatePreferenceBody.DarkModeEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdatePreferenceBody
     */
    showExplicit?: UpdatePreferenceBody.ShowExplicitEnum;
}

/**
 * @export
 * @namespace UpdatePreferenceBody
 */
export namespace UpdatePreferenceBody {
    /**
     * @export
     * @enum {string}
     */
    export enum LanguageEnum {
        EnUS = <any> 'en-US',
        JaJP = <any> 'ja-JP',
        IdID = <any> 'id-ID'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DarkModeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ShowExplicitEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface UpdateSocialBody
 */
export interface UpdateSocialBody {
    /**
     * 
     * @type {number}
     * @memberof UpdateSocialBody
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateSocialBody
     */
    facebook?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSocialBody
     */
    instagram?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSocialBody
     */
    patreon?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSocialBody
     */
    twitter?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSocialBody
     */
    youtube?: string;
}
/**
 * 
 * @export
 * @interface UpdateUsernameBody
 */
export interface UpdateUsernameBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateUsernameBody
     */
    newUsername: string;
}
/**
 * 
 * @export
 * @interface UserAllModel
 */
export interface UserAllModel extends UserModel {
    /**
     * 
     * @type {UserSocialModel}
     * @memberof UserAllModel
     */
    userSocials?: UserSocialModel;
    /**
     * 
     * @type {UserSettingModel}
     * @memberof UserAllModel
     */
    userSettings?: UserSettingModel;
}

/**
 * @export
 * @namespace UserAllModel
 */
export namespace UserAllModel {
}
/**
 * 
 * @export
 * @interface UserLiteModel
 */
export interface UserLiteModel {
    /**
     * 
     * @type {number}
     * @memberof UserLiteModel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    penName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    avatarDriver?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    avatarBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    avatarB2FileId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLiteModel
     */
    avatarFilename?: string;
    /**
     * 
     * @type {number}
     * @memberof UserLiteModel
     */
    emailVerified?: UserLiteModel.EmailVerifiedEnum;
}

/**
 * @export
 * @namespace UserLiteModel
 */
export namespace UserLiteModel {
    /**
     * @export
     * @enum {string}
     */
    export enum EmailVerifiedEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface UserModel
 */
export interface UserModel extends UserLiteModel {
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    bio?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    gender?: UserModel.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    coverDriver?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    coverBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    coverB2FileId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    coverFilename?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    createdAt?: string;
}

/**
 * @export
 * @namespace UserModel
 */
export namespace UserModel {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        M = <any> 'm',
        F = <any> 'f'
    }
}
/**
 * 
 * @export
 * @interface UserSettingModel
 */
export interface UserSettingModel {
    /**
     * 
     * @type {number}
     * @memberof UserSettingModel
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof UserSettingModel
     */
    darkMode?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSettingModel
     */
    language?: string;
    /**
     * 
     * @type {number}
     * @memberof UserSettingModel
     */
    showExplicit?: number;
}
/**
 * 
 * @export
 * @interface UserSocialModel
 */
export interface UserSocialModel {
    /**
     * 
     * @type {number}
     * @memberof UserSocialModel
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSocialModel
     */
    facebook?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSocialModel
     */
    instagram?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSocialModel
     */
    patreon?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSocialModel
     */
    twitter?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSocialModel
     */
    youtube?: string;
}
/**
 * 
 * @export
 * @interface WorkRemoveBody
 */
export interface WorkRemoveBody {
    /**
     * 
     * @type {number}
     * @memberof WorkRemoveBody
     */
    albumId: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof WorkRemoveBody
     */
    workIds: Array<number>;
}
/**
 * AlbumsApi - fetch parameter creator
 * @export
 */
export const AlbumsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add artwork(s) to album
         * @param {AlbumsAddworkBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkToAlbum(body?: AlbumsAddworkBody, options: any = {}): FetchArgs {
            const localVarPath = `/albums/add-work`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlbumsAddworkBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new album
         * @param {AlbumsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(body?: AlbumsCreateBody, options: any = {}): FetchArgs {
            const localVarPath = `/albums/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlbumsCreateBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an album
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAlbum.');
            }
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View detailed information about the album
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAlbumById.');
            }
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List album items
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumItems(id: number, perPage: number, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAlbumItems.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getAlbumItems.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAlbumItems.');
            }
            const localVarPath = `/albums/list/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List wherever the item were saved
         * @param {string} type 
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAlbumSaveInfo(type: string, workId: number, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getCurrentAlbumSaveInfo.');
            }
            // verify required parameter 'workId' is not null or undefined
            if (workId === null || workId === undefined) {
                throw new RequiredError('workId','Required parameter workId was null or undefined when calling getCurrentAlbumSaveInfo.');
            }
            const localVarPath = `/albums/current/{type}/{work_id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"work_id"}}`, encodeURIComponent(String(workId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user's albums
         * @param {number} userId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAlbums(userId: number, perPage: number, page: number, type: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserAlbums.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling listUserAlbums.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling listUserAlbums.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling listUserAlbums.');
            }
            const localVarPath = `/albums/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a work(s) from album
         * @param {WorkRemoveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkFromAlbum(body?: WorkRemoveBody, options: any = {}): FetchArgs {
            const localVarPath = `/albums/work/remove`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WorkRemoveBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update information of current existing album
         * @param {AlbumsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbum(body?: AlbumsBody, options: any = {}): FetchArgs {
            const localVarPath = `/albums`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlbumsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumsApi - functional programming interface
 * @export
 */
export const AlbumsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add artwork(s) to album
         * @param {AlbumsAddworkBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkToAlbum(body?: AlbumsAddworkBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).addWorkToAlbum(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new album
         * @param {AlbumsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(body?: AlbumsCreateBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).createAlbum(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete an album
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).deleteAlbum(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View detailed information about the album
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlbumLiteModel> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).getAlbumById(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List album items
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumItems(id: number, perPage: number, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).getAlbumItems(id, perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List wherever the item were saved
         * @param {string} type 
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAlbumSaveInfo(type: string, workId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).getCurrentAlbumSaveInfo(type, workId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List user's albums
         * @param {number} userId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAlbums(userId: number, perPage: number, page: number, type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).listUserAlbums(userId, perPage, page, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a work(s) from album
         * @param {WorkRemoveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkFromAlbum(body?: WorkRemoveBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).removeWorkFromAlbum(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update information of current existing album
         * @param {AlbumsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbum(body?: AlbumsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AlbumsApiFetchParamCreator(configuration).updateAlbum(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AlbumsApi - factory interface
 * @export
 */
export const AlbumsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add artwork(s) to album
         * @param {AlbumsAddworkBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkToAlbum(body?: AlbumsAddworkBody, options?: any) {
            return AlbumsApiFp(configuration).addWorkToAlbum(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new album
         * @param {AlbumsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(body?: AlbumsCreateBody, options?: any) {
            return AlbumsApiFp(configuration).createAlbum(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an album
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(id: number, options?: any) {
            return AlbumsApiFp(configuration).deleteAlbum(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View detailed information about the album
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumById(id: number, options?: any) {
            return AlbumsApiFp(configuration).getAlbumById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List album items
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumItems(id: number, perPage: number, page: number, options?: any) {
            return AlbumsApiFp(configuration).getAlbumItems(id, perPage, page, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List wherever the item were saved
         * @param {string} type 
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAlbumSaveInfo(type: string, workId: number, options?: any) {
            return AlbumsApiFp(configuration).getCurrentAlbumSaveInfo(type, workId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List user's albums
         * @param {number} userId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAlbums(userId: number, perPage: number, page: number, type: string, options?: any) {
            return AlbumsApiFp(configuration).listUserAlbums(userId, perPage, page, type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a work(s) from album
         * @param {WorkRemoveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkFromAlbum(body?: WorkRemoveBody, options?: any) {
            return AlbumsApiFp(configuration).removeWorkFromAlbum(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update information of current existing album
         * @param {AlbumsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbum(body?: AlbumsBody, options?: any) {
            return AlbumsApiFp(configuration).updateAlbum(body, options)(fetch, basePath);
        },
    };
};

/**
 * AlbumsApi - object-oriented interface
 * @export
 * @class AlbumsApi
 * @extends {BaseAPI}
 */
export class AlbumsApi extends BaseAPI {
    /**
     * 
     * @summary Add artwork(s) to album
     * @param {AlbumsAddworkBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public addWorkToAlbum(body?: AlbumsAddworkBody, options?: any) {
        return AlbumsApiFp(this.configuration).addWorkToAlbum(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new album
     * @param {AlbumsCreateBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public createAlbum(body?: AlbumsCreateBody, options?: any) {
        return AlbumsApiFp(this.configuration).createAlbum(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete an album
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public deleteAlbum(id: number, options?: any) {
        return AlbumsApiFp(this.configuration).deleteAlbum(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View detailed information about the album
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getAlbumById(id: number, options?: any) {
        return AlbumsApiFp(this.configuration).getAlbumById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List album items
     * @param {number} id 
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getAlbumItems(id: number, perPage: number, page: number, options?: any) {
        return AlbumsApiFp(this.configuration).getAlbumItems(id, perPage, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List wherever the item were saved
     * @param {string} type 
     * @param {number} workId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getCurrentAlbumSaveInfo(type: string, workId: number, options?: any) {
        return AlbumsApiFp(this.configuration).getCurrentAlbumSaveInfo(type, workId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List user's albums
     * @param {number} userId 
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public listUserAlbums(userId: number, perPage: number, page: number, type: string, options?: any) {
        return AlbumsApiFp(this.configuration).listUserAlbums(userId, perPage, page, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a work(s) from album
     * @param {WorkRemoveBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public removeWorkFromAlbum(body?: WorkRemoveBody, options?: any) {
        return AlbumsApiFp(this.configuration).removeWorkFromAlbum(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update information of current existing album
     * @param {AlbumsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public updateAlbum(body?: AlbumsBody, options?: any) {
        return AlbumsApiFp(this.configuration).updateAlbum(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkCRUDApi - fetch parameter creator
 * @export
 */
export const ArtworkCRUDApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove artwork
         * @param {Array<number>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWork(body?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/artworks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/upload new artworks
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {number} [isExplicit] 
         * @param {string} [scheduledPost] 
         * @param {Array<Blob>} [files] 
         * @param {Array<number>} [fileOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(title?: string, description?: string, tags?: string, isExplicit?: number, scheduledPost?: string, files?: Array<Blob>, fileOrder?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/artworks/post`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication bearerAuth required

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            if (tags !== undefined) {
                localVarFormParams.set('tags', tags as any);
            }

            if (isExplicit !== undefined) {
                localVarFormParams.set('is_explicit', isExplicit as any);
            }

            if (scheduledPost !== undefined) {
                localVarFormParams.set('scheduled_post', scheduledPost as any);
            }

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files[]', element as any);
                })
            }

            if (fileOrder) {
                fileOrder.forEach((element) => {
                    localVarFormParams.append('file_order[]', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing artwork information
         * @param {ArtworksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWork(body?: ArtworksBody, options: any = {}): FetchArgs {
            const localVarPath = `/artworks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArtworksBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View detail information of artwork
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        view(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling view.');
            }
            const localVarPath = `/artworks/view/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkCRUDApi - functional programming interface
 * @export
 */
export const ArtworkCRUDApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove artwork
         * @param {Array<number>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWork(body?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkCRUDApiFetchParamCreator(configuration).deleteWork(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create/upload new artworks
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {number} [isExplicit] 
         * @param {string} [scheduledPost] 
         * @param {Array<Blob>} [files] 
         * @param {Array<number>} [fileOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(title?: string, description?: string, tags?: string, isExplicit?: number, scheduledPost?: string, files?: Array<Blob>, fileOrder?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2011> {
            const localVarFetchArgs = ArtworkCRUDApiFetchParamCreator(configuration).post(title, description, tags, isExplicit, scheduledPost, files, fileOrder, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update existing artwork information
         * @param {ArtworksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWork(body?: ArtworksBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkCRUDApiFetchParamCreator(configuration).updateWork(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary View detail information of artwork
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        view(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArtworkModel> {
            const localVarFetchArgs = ArtworkCRUDApiFetchParamCreator(configuration).view(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkCRUDApi - factory interface
 * @export
 */
export const ArtworkCRUDApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Remove artwork
         * @param {Array<number>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWork(body?: Array<number>, options?: any) {
            return ArtworkCRUDApiFp(configuration).deleteWork(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create/upload new artworks
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {number} [isExplicit] 
         * @param {string} [scheduledPost] 
         * @param {Array<Blob>} [files] 
         * @param {Array<number>} [fileOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(title?: string, description?: string, tags?: string, isExplicit?: number, scheduledPost?: string, files?: Array<Blob>, fileOrder?: Array<number>, options?: any) {
            return ArtworkCRUDApiFp(configuration).post(title, description, tags, isExplicit, scheduledPost, files, fileOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update existing artwork information
         * @param {ArtworksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWork(body?: ArtworksBody, options?: any) {
            return ArtworkCRUDApiFp(configuration).updateWork(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary View detail information of artwork
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        view(id: number, options?: any) {
            return ArtworkCRUDApiFp(configuration).view(id, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkCRUDApi - object-oriented interface
 * @export
 * @class ArtworkCRUDApi
 * @extends {BaseAPI}
 */
export class ArtworkCRUDApi extends BaseAPI {
    /**
     * 
     * @summary Remove artwork
     * @param {Array<number>} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCRUDApi
     */
    public deleteWork(body?: Array<number>, options?: any) {
        return ArtworkCRUDApiFp(this.configuration).deleteWork(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create/upload new artworks
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [tags] 
     * @param {number} [isExplicit] 
     * @param {string} [scheduledPost] 
     * @param {Array<Blob>} [files] 
     * @param {Array<number>} [fileOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCRUDApi
     */
    public post(title?: string, description?: string, tags?: string, isExplicit?: number, scheduledPost?: string, files?: Array<Blob>, fileOrder?: Array<number>, options?: any) {
        return ArtworkCRUDApiFp(this.configuration).post(title, description, tags, isExplicit, scheduledPost, files, fileOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update existing artwork information
     * @param {ArtworksBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCRUDApi
     */
    public updateWork(body?: ArtworksBody, options?: any) {
        return ArtworkCRUDApiFp(this.configuration).updateWork(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary View detail information of artwork
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCRUDApi
     */
    public view(id: number, options?: any) {
        return ArtworkCRUDApiFp(this.configuration).view(id, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkCommentsApi - fetch parameter creator
 * @export
 */
export const ArtworkCommentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new comment to artwork
         * @param {ArtworksCommentsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(body?: ArtworksCommentsBody, options: any = {}): FetchArgs {
            const localVarPath = `/artworks/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArtworksCommentsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List comments of artwork
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id: number, perPage: number, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getComments.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getComments.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getComments.');
            }
            const localVarPath = `/artworks/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeComment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeComment.');
            }
            const localVarPath = `/artworks/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkCommentsApi - functional programming interface
 * @export
 */
export const ArtworkCommentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new comment to artwork
         * @param {ArtworksCommentsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(body?: ArtworksCommentsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2013> {
            const localVarFetchArgs = ArtworkCommentsApiFetchParamCreator(configuration).addComment(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List comments of artwork
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id: number, perPage: number, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = ArtworkCommentsApiFetchParamCreator(configuration).getComments(id, perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeComment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkCommentsApiFetchParamCreator(configuration).removeComment(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkCommentsApi - factory interface
 * @export
 */
export const ArtworkCommentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add new comment to artwork
         * @param {ArtworksCommentsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(body?: ArtworksCommentsBody, options?: any) {
            return ArtworkCommentsApiFp(configuration).addComment(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List comments of artwork
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id: number, perPage: number, page: number, options?: any) {
            return ArtworkCommentsApiFp(configuration).getComments(id, perPage, page, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeComment(id: number, options?: any) {
            return ArtworkCommentsApiFp(configuration).removeComment(id, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkCommentsApi - object-oriented interface
 * @export
 * @class ArtworkCommentsApi
 * @extends {BaseAPI}
 */
export class ArtworkCommentsApi extends BaseAPI {
    /**
     * 
     * @summary Add new comment to artwork
     * @param {ArtworksCommentsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsApi
     */
    public addComment(body?: ArtworksCommentsBody, options?: any) {
        return ArtworkCommentsApiFp(this.configuration).addComment(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List comments of artwork
     * @param {number} id 
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsApi
     */
    public getComments(id: number, perPage: number, page: number, options?: any) {
        return ArtworkCommentsApiFp(this.configuration).getComments(id, perPage, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a comment
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsApi
     */
    public removeComment(id: number, options?: any) {
        return ArtworkCommentsApiFp(this.configuration).removeComment(id, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkCommentsLikesApi - fetch parameter creator
 * @export
 */
export const ArtworkCommentsLikesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Like a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeAComment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling likeAComment.');
            }
            const localVarPath = `/artworks/comments/like/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlike a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeAComment(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlikeAComment.');
            }
            const localVarPath = `/artworks/comments/unlike/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkCommentsLikesApi - functional programming interface
 * @export
 */
export const ArtworkCommentsLikesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Like a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeAComment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = ArtworkCommentsLikesApiFetchParamCreator(configuration).likeAComment(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unlike a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeAComment(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkCommentsLikesApiFetchParamCreator(configuration).unlikeAComment(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkCommentsLikesApi - factory interface
 * @export
 */
export const ArtworkCommentsLikesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Like a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeAComment(id: number, options?: any) {
            return ArtworkCommentsLikesApiFp(configuration).likeAComment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unlike a comment
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeAComment(id: number, options?: any) {
            return ArtworkCommentsLikesApiFp(configuration).unlikeAComment(id, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkCommentsLikesApi - object-oriented interface
 * @export
 * @class ArtworkCommentsLikesApi
 * @extends {BaseAPI}
 */
export class ArtworkCommentsLikesApi extends BaseAPI {
    /**
     * 
     * @summary Like a comment
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsLikesApi
     */
    public likeAComment(id: number, options?: any) {
        return ArtworkCommentsLikesApiFp(this.configuration).likeAComment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unlike a comment
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsLikesApi
     */
    public unlikeAComment(id: number, options?: any) {
        return ArtworkCommentsLikesApiFp(this.configuration).unlikeAComment(id, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkCommentsRepliesApi - fetch parameter creator
 * @export
 */
export const ArtworkCommentsRepliesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List replies of comment
         * @param {number} commentId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplies(commentId: number, perPage: number, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling getReplies.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getReplies.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getReplies.');
            }
            const localVarPath = `/artworks/comments/replies/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Like a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeReply(replyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'replyId' is not null or undefined
            if (replyId === null || replyId === undefined) {
                throw new RequiredError('replyId','Required parameter replyId was null or undefined when calling likeReply.');
            }
            const localVarPath = `/artworks/comments/reply/like/{replyId}`
                .replace(`{${"replyId"}}`, encodeURIComponent(String(replyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReply(replyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'replyId' is not null or undefined
            if (replyId === null || replyId === undefined) {
                throw new RequiredError('replyId','Required parameter replyId was null or undefined when calling removeReply.');
            }
            const localVarPath = `/artworks/comments/reply/{replyId}`
                .replace(`{${"replyId"}}`, encodeURIComponent(String(replyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reply a comment
         * @param {CommentsReplyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reply(body?: CommentsReplyBody, options: any = {}): FetchArgs {
            const localVarPath = `/artworks/comments/reply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommentsReplyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlike a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeReply(replyId: number, options: any = {}): FetchArgs {
            // verify required parameter 'replyId' is not null or undefined
            if (replyId === null || replyId === undefined) {
                throw new RequiredError('replyId','Required parameter replyId was null or undefined when calling unlikeReply.');
            }
            const localVarPath = `/artworks/comments/reply/unlike/{replyId}`
                .replace(`{${"replyId"}}`, encodeURIComponent(String(replyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkCommentsRepliesApi - functional programming interface
 * @export
 */
export const ArtworkCommentsRepliesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List replies of comment
         * @param {number} commentId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplies(commentId: number, perPage: number, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20019> {
            const localVarFetchArgs = ArtworkCommentsRepliesApiFetchParamCreator(configuration).getReplies(commentId, perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Like a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeReply(replyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkCommentsRepliesApiFetchParamCreator(configuration).likeReply(replyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReply(replyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkCommentsRepliesApiFetchParamCreator(configuration).removeReply(replyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reply a comment
         * @param {CommentsReplyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reply(body?: CommentsReplyBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2014> {
            const localVarFetchArgs = ArtworkCommentsRepliesApiFetchParamCreator(configuration).reply(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unlike a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeReply(replyId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkCommentsRepliesApiFetchParamCreator(configuration).unlikeReply(replyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkCommentsRepliesApi - factory interface
 * @export
 */
export const ArtworkCommentsRepliesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List replies of comment
         * @param {number} commentId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplies(commentId: number, perPage: number, page: number, options?: any) {
            return ArtworkCommentsRepliesApiFp(configuration).getReplies(commentId, perPage, page, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Like a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeReply(replyId: number, options?: any) {
            return ArtworkCommentsRepliesApiFp(configuration).likeReply(replyId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReply(replyId: number, options?: any) {
            return ArtworkCommentsRepliesApiFp(configuration).removeReply(replyId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reply a comment
         * @param {CommentsReplyBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reply(body?: CommentsReplyBody, options?: any) {
            return ArtworkCommentsRepliesApiFp(configuration).reply(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unlike a reply
         * @param {number} replyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeReply(replyId: number, options?: any) {
            return ArtworkCommentsRepliesApiFp(configuration).unlikeReply(replyId, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkCommentsRepliesApi - object-oriented interface
 * @export
 * @class ArtworkCommentsRepliesApi
 * @extends {BaseAPI}
 */
export class ArtworkCommentsRepliesApi extends BaseAPI {
    /**
     * 
     * @summary List replies of comment
     * @param {number} commentId 
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsRepliesApi
     */
    public getReplies(commentId: number, perPage: number, page: number, options?: any) {
        return ArtworkCommentsRepliesApiFp(this.configuration).getReplies(commentId, perPage, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Like a reply
     * @param {number} replyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsRepliesApi
     */
    public likeReply(replyId: number, options?: any) {
        return ArtworkCommentsRepliesApiFp(this.configuration).likeReply(replyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a reply
     * @param {number} replyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsRepliesApi
     */
    public removeReply(replyId: number, options?: any) {
        return ArtworkCommentsRepliesApiFp(this.configuration).removeReply(replyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reply a comment
     * @param {CommentsReplyBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsRepliesApi
     */
    public reply(body?: CommentsReplyBody, options?: any) {
        return ArtworkCommentsRepliesApiFp(this.configuration).reply(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unlike a reply
     * @param {number} replyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkCommentsRepliesApi
     */
    public unlikeReply(replyId: number, options?: any) {
        return ArtworkCommentsRepliesApiFp(this.configuration).unlikeReply(replyId, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkLikesApi - fetch parameter creator
 * @export
 */
export const ArtworkLikesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count how many like does the work have
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countLikes(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling countLikes.');
            }
            const localVarPath = `/artworks/count-likes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Like an artwork
         * @param {ArtworksLikeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        like(body?: ArtworksLikeBody, options: any = {}): FetchArgs {
            const localVarPath = `/artworks/like`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArtworksLikeBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlike a liked artwork
         * @param {ArtworksUnlikeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlike(body?: ArtworksUnlikeBody, options: any = {}): FetchArgs {
            const localVarPath = `/artworks/unlike`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArtworksUnlikeBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkLikesApi - functional programming interface
 * @export
 */
export const ArtworkLikesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count how many like does the work have
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countLikes(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = ArtworkLikesApiFetchParamCreator(configuration).countLikes(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Like an artwork
         * @param {ArtworksLikeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        like(body?: ArtworksLikeBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkLikesApiFetchParamCreator(configuration).like(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unlike a liked artwork
         * @param {ArtworksUnlikeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlike(body?: ArtworksUnlikeBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkLikesApiFetchParamCreator(configuration).unlike(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkLikesApi - factory interface
 * @export
 */
export const ArtworkLikesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count how many like does the work have
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countLikes(id: number, options?: any) {
            return ArtworkLikesApiFp(configuration).countLikes(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Like an artwork
         * @param {ArtworksLikeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        like(body?: ArtworksLikeBody, options?: any) {
            return ArtworkLikesApiFp(configuration).like(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unlike a liked artwork
         * @param {ArtworksUnlikeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlike(body?: ArtworksUnlikeBody, options?: any) {
            return ArtworkLikesApiFp(configuration).unlike(body, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkLikesApi - object-oriented interface
 * @export
 * @class ArtworkLikesApi
 * @extends {BaseAPI}
 */
export class ArtworkLikesApi extends BaseAPI {
    /**
     * 
     * @summary Count how many like does the work have
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkLikesApi
     */
    public countLikes(id: number, options?: any) {
        return ArtworkLikesApiFp(this.configuration).countLikes(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Like an artwork
     * @param {ArtworksLikeBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkLikesApi
     */
    public like(body?: ArtworksLikeBody, options?: any) {
        return ArtworkLikesApiFp(this.configuration).like(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unlike a liked artwork
     * @param {ArtworksUnlikeBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkLikesApi
     */
    public unlike(body?: ArtworksUnlikeBody, options?: any) {
        return ArtworkLikesApiFp(this.configuration).unlike(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkListApi - fetch parameter creator
 * @export
 */
export const ArtworkListApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get latest uploaded artworks from followed users
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingArtworks(perPage: number, page: number, mode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getFollowingArtworks.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getFollowingArtworks.');
            }
            const localVarPath = `/artworks/following`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List latest uploaded artworks
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {string} [tags] 
         * @param {boolean} [following] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestWorks(perPage: number, page: number, mode?: string, tags?: string, following?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getLatestWorks.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getLatestWorks.');
            }
            const localVarPath = `/artworks/latest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (following !== undefined) {
                localVarQueryParameter['following'] = following;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List most popular artworks (with advanced sort and filter features)
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} range 
         * @param {string} by 
         * @param {string} [mode] 
         * @param {string} [tags] 
         * @param {boolean} [following] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostPopular(perPage: number, page: number, range: string, by: string, mode?: string, tags?: string, following?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getMostPopular.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getMostPopular.');
            }
            // verify required parameter 'range' is not null or undefined
            if (range === null || range === undefined) {
                throw new RequiredError('range','Required parameter range was null or undefined when calling getMostPopular.');
            }
            // verify required parameter 'by' is not null or undefined
            if (by === null || by === undefined) {
                throw new RequiredError('by','Required parameter by was null or undefined when calling getMostPopular.');
            }
            const localVarPath = `/artworks/most`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (following !== undefined) {
                localVarQueryParameter['following'] = following;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artworks that related to currently viewed artwork
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedArtworks(workId: number, options: any = {}): FetchArgs {
            // verify required parameter 'workId' is not null or undefined
            if (workId === null || workId === undefined) {
                throw new RequiredError('workId','Required parameter workId was null or undefined when calling getRelatedArtworks.');
            }
            const localVarPath = `/artworks/related/{workId}`
                .replace(`{${"workId"}}`, encodeURIComponent(String(workId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication none required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user's artworks
         * @param {number} userId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserArtworks(userId: number, perPage: number, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserArtworks.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getUserArtworks.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserArtworks.');
            }
            const localVarPath = `/artworks/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkListApi - functional programming interface
 * @export
 */
export const ArtworkListApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get latest uploaded artworks from followed users
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingArtworks(perPage: number, page: number, mode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20022> {
            const localVarFetchArgs = ArtworkListApiFetchParamCreator(configuration).getFollowingArtworks(perPage, page, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List latest uploaded artworks
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {string} [tags] 
         * @param {boolean} [following] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestWorks(perPage: number, page: number, mode?: string, tags?: string, following?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = ArtworkListApiFetchParamCreator(configuration).getLatestWorks(perPage, page, mode, tags, following, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List most popular artworks (with advanced sort and filter features)
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} range 
         * @param {string} by 
         * @param {string} [mode] 
         * @param {string} [tags] 
         * @param {boolean} [following] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostPopular(perPage: number, page: number, range: string, by: string, mode?: string, tags?: string, following?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = ArtworkListApiFetchParamCreator(configuration).getMostPopular(perPage, page, range, by, mode, tags, following, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get artworks that related to currently viewed artwork
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedArtworks(workId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = ArtworkListApiFetchParamCreator(configuration).getRelatedArtworks(workId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List user's artworks
         * @param {number} userId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserArtworks(userId: number, perPage: number, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = ArtworkListApiFetchParamCreator(configuration).getUserArtworks(userId, perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkListApi - factory interface
 * @export
 */
export const ArtworkListApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get latest uploaded artworks from followed users
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingArtworks(perPage: number, page: number, mode?: string, options?: any) {
            return ArtworkListApiFp(configuration).getFollowingArtworks(perPage, page, mode, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List latest uploaded artworks
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {string} [tags] 
         * @param {boolean} [following] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestWorks(perPage: number, page: number, mode?: string, tags?: string, following?: boolean, options?: any) {
            return ArtworkListApiFp(configuration).getLatestWorks(perPage, page, mode, tags, following, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List most popular artworks (with advanced sort and filter features)
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} range 
         * @param {string} by 
         * @param {string} [mode] 
         * @param {string} [tags] 
         * @param {boolean} [following] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostPopular(perPage: number, page: number, range: string, by: string, mode?: string, tags?: string, following?: boolean, options?: any) {
            return ArtworkListApiFp(configuration).getMostPopular(perPage, page, range, by, mode, tags, following, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get artworks that related to currently viewed artwork
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedArtworks(workId: number, options?: any) {
            return ArtworkListApiFp(configuration).getRelatedArtworks(workId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List user's artworks
         * @param {number} userId 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserArtworks(userId: number, perPage: number, page: number, options?: any) {
            return ArtworkListApiFp(configuration).getUserArtworks(userId, perPage, page, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkListApi - object-oriented interface
 * @export
 * @class ArtworkListApi
 * @extends {BaseAPI}
 */
export class ArtworkListApi extends BaseAPI {
    /**
     * 
     * @summary Get latest uploaded artworks from followed users
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {string} [mode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkListApi
     */
    public getFollowingArtworks(perPage: number, page: number, mode?: string, options?: any) {
        return ArtworkListApiFp(this.configuration).getFollowingArtworks(perPage, page, mode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List latest uploaded artworks
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {string} [mode] 
     * @param {string} [tags] 
     * @param {boolean} [following] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkListApi
     */
    public getLatestWorks(perPage: number, page: number, mode?: string, tags?: string, following?: boolean, options?: any) {
        return ArtworkListApiFp(this.configuration).getLatestWorks(perPage, page, mode, tags, following, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List most popular artworks (with advanced sort and filter features)
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {string} range 
     * @param {string} by 
     * @param {string} [mode] 
     * @param {string} [tags] 
     * @param {boolean} [following] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkListApi
     */
    public getMostPopular(perPage: number, page: number, range: string, by: string, mode?: string, tags?: string, following?: boolean, options?: any) {
        return ArtworkListApiFp(this.configuration).getMostPopular(perPage, page, range, by, mode, tags, following, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get artworks that related to currently viewed artwork
     * @param {number} workId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkListApi
     */
    public getRelatedArtworks(workId: number, options?: any) {
        return ArtworkListApiFp(this.configuration).getRelatedArtworks(workId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List user's artworks
     * @param {number} userId 
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkListApi
     */
    public getUserArtworks(userId: number, perPage: number, page: number, options?: any) {
        return ArtworkListApiFp(this.configuration).getUserArtworks(userId, perPage, page, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkRandomApi - fetch parameter creator
 * @export
 */
export const ArtworkRandomApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Roll a dice and get a random artwork
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomArtwork(options: any = {}): FetchArgs {
            const localVarPath = `/artworks/random`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkRandomApi - functional programming interface
 * @export
 */
export const ArtworkRandomApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Roll a dice and get a random artwork
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomArtwork(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = ArtworkRandomApiFetchParamCreator(configuration).getRandomArtwork(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkRandomApi - factory interface
 * @export
 */
export const ArtworkRandomApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Roll a dice and get a random artwork
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomArtwork(options?: any) {
            return ArtworkRandomApiFp(configuration).getRandomArtwork(options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkRandomApi - object-oriented interface
 * @export
 * @class ArtworkRandomApi
 * @extends {BaseAPI}
 */
export class ArtworkRandomApi extends BaseAPI {
    /**
     * 
     * @summary Roll a dice and get a random artwork
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkRandomApi
     */
    public getRandomArtwork(options?: any) {
        return ArtworkRandomApiFp(this.configuration).getRandomArtwork(options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkTagsApi - fetch parameter creator
 * @export
 */
export const ArtworkTagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get tag keys by comma separated tags
         * @param {string} tags 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeysByTags(tags: string, options: any = {}): FetchArgs {
            // verify required parameter 'tags' is not null or undefined
            if (tags === null || tags === undefined) {
                throw new RequiredError('tags','Required parameter tags was null or undefined when calling getKeysByTags.');
            }
            const localVarPath = `/artworks/tags/get-keys-by-tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search available tags by keyword given
         * @param {string} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(keyword: string, options: any = {}): FetchArgs {
            // verify required parameter 'keyword' is not null or undefined
            if (keyword === null || keyword === undefined) {
                throw new RequiredError('keyword','Required parameter keyword was null or undefined when calling searchTags.');
            }
            const localVarPath = `/artworks/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkTagsApi - functional programming interface
 * @export
 */
export const ArtworkTagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get tag keys by comma separated tags
         * @param {string} tags 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeysByTags(tags: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = ArtworkTagsApiFetchParamCreator(configuration).getKeysByTags(tags, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search available tags by keyword given
         * @param {string} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(keyword: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20023>> {
            const localVarFetchArgs = ArtworkTagsApiFetchParamCreator(configuration).searchTags(keyword, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkTagsApi - factory interface
 * @export
 */
export const ArtworkTagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get tag keys by comma separated tags
         * @param {string} tags 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeysByTags(tags: string, options?: any) {
            return ArtworkTagsApiFp(configuration).getKeysByTags(tags, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search available tags by keyword given
         * @param {string} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(keyword: string, options?: any) {
            return ArtworkTagsApiFp(configuration).searchTags(keyword, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkTagsApi - object-oriented interface
 * @export
 * @class ArtworkTagsApi
 * @extends {BaseAPI}
 */
export class ArtworkTagsApi extends BaseAPI {
    /**
     * 
     * @summary Get tag keys by comma separated tags
     * @param {string} tags 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkTagsApi
     */
    public getKeysByTags(tags: string, options?: any) {
        return ArtworkTagsApiFp(this.configuration).getKeysByTags(tags, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search available tags by keyword given
     * @param {string} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkTagsApi
     */
    public searchTags(keyword: string, options?: any) {
        return ArtworkTagsApiFp(this.configuration).searchTags(keyword, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworkViewsApi - fetch parameter creator
 * @export
 */
export const ArtworkViewsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Increase view count of artwork
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addViewCount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addViewCount.');
            }
            const localVarPath = `/artworks/add-view/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countViews(id: number, mode: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling countViews.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling countViews.');
            }
            const localVarPath = `/artworks/count-views/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworkViewsApi - functional programming interface
 * @export
 */
export const ArtworkViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Increase view count of artwork
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addViewCount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ArtworkViewsApiFetchParamCreator(configuration).addViewCount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countViews(id: number, mode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20021> {
            const localVarFetchArgs = ArtworkViewsApiFetchParamCreator(configuration).countViews(id, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworkViewsApi - factory interface
 * @export
 */
export const ArtworkViewsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Increase view count of artwork
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addViewCount(id: number, options?: any) {
            return ArtworkViewsApiFp(configuration).addViewCount(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countViews(id: number, mode: string, options?: any) {
            return ArtworkViewsApiFp(configuration).countViews(id, mode, options)(fetch, basePath);
        },
    };
};

/**
 * ArtworkViewsApi - object-oriented interface
 * @export
 * @class ArtworkViewsApi
 * @extends {BaseAPI}
 */
export class ArtworkViewsApi extends BaseAPI {
    /**
     * 
     * @summary Increase view count of artwork
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkViewsApi
     */
    public addViewCount(id: number, options?: any) {
        return ArtworkViewsApiFp(this.configuration).addViewCount(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworkViewsApi
     */
    public countViews(id: number, mode: string, options?: any) {
        return ArtworkViewsApiFp(this.configuration).countViews(id, mode, options)(this.fetch, this.basePath);
    }

}
/**
 * ArtworksApi - fetch parameter creator
 * @export
 */
export const ArtworksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if there is an artwork to show to the user/visitor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkArtworkAvailability(options: any = {}): FetchArgs {
            const localVarPath = `/artworks/check-availability`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication none required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtworksApi - functional programming interface
 * @export
 */
export const ArtworksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if there is an artwork to show to the user/visitor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkArtworkAvailability(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = ArtworksApiFetchParamCreator(configuration).checkArtworkAvailability(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtworksApi - factory interface
 * @export
 */
export const ArtworksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Check if there is an artwork to show to the user/visitor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkArtworkAvailability(options?: any) {
            return ArtworksApiFp(configuration).checkArtworkAvailability(options)(fetch, basePath);
        },
    };
};

/**
 * ArtworksApi - object-oriented interface
 * @export
 * @class ArtworksApi
 * @extends {BaseAPI}
 */
export class ArtworksApi extends BaseAPI {
    /**
     * 
     * @summary Check if there is an artwork to show to the user/visitor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtworksApi
     */
    public checkArtworkAvailability(options?: any) {
        return ArtworksApiFp(this.configuration).checkArtworkAvailability(options)(this.fetch, this.basePath);
    }

}
/**
 * AuthServiceAuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthServiceAuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate user
         * @param {AuthAuthenticateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body?: AuthAuthenticateBody, options: any = {}): FetchArgs {
            const localVarPath = `/auth/authenticate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthAuthenticateBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh current token
         * @param {AuthRefreshBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(body?: AuthRefreshBody, options: any = {}): FetchArgs {
            const localVarPath = `/auth/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthRefreshBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if auth token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCheck(options: any = {}): FetchArgs {
            const localVarPath = `/auth/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthServiceAuthenticationApi - functional programming interface
 * @export
 */
export const AuthServiceAuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate user
         * @param {AuthAuthenticateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body?: AuthAuthenticateBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = AuthServiceAuthenticationApiFetchParamCreator(configuration).authenticate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Refresh current token
         * @param {AuthRefreshBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(body?: AuthRefreshBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = AuthServiceAuthenticationApiFetchParamCreator(configuration).refreshToken(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check if auth token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCheck(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = AuthServiceAuthenticationApiFetchParamCreator(configuration).tokenCheck(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthServiceAuthenticationApi - factory interface
 * @export
 */
export const AuthServiceAuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Authenticate user
         * @param {AuthAuthenticateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body?: AuthAuthenticateBody, options?: any) {
            return AuthServiceAuthenticationApiFp(configuration).authenticate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Refresh current token
         * @param {AuthRefreshBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(body?: AuthRefreshBody, options?: any) {
            return AuthServiceAuthenticationApiFp(configuration).refreshToken(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check if auth token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCheck(options?: any) {
            return AuthServiceAuthenticationApiFp(configuration).tokenCheck(options)(fetch, basePath);
        },
    };
};

/**
 * AuthServiceAuthenticationApi - object-oriented interface
 * @export
 * @class AuthServiceAuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthServiceAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate user
     * @param {AuthAuthenticateBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceAuthenticationApi
     */
    public authenticate(body?: AuthAuthenticateBody, options?: any) {
        return AuthServiceAuthenticationApiFp(this.configuration).authenticate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Refresh current token
     * @param {AuthRefreshBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceAuthenticationApi
     */
    public refreshToken(body?: AuthRefreshBody, options?: any) {
        return AuthServiceAuthenticationApiFp(this.configuration).refreshToken(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check if auth token is valid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceAuthenticationApi
     */
    public tokenCheck(options?: any) {
        return AuthServiceAuthenticationApiFp(this.configuration).tokenCheck(options)(this.fetch, this.basePath);
    }

}
/**
 * AuthServiceRegistrationApi - fetch parameter creator
 * @export
 */
export const AuthServiceRegistrationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if the email is already taken or not
         * @param {CheckEmailBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEmail(body?: CheckEmailBody, options: any = {}): FetchArgs {
            const localVarPath = `/auth/registration/check/email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckEmailBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the username is already taken or not
         * @param {CheckUsernameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(body?: CheckUsernameBody, options: any = {}): FetchArgs {
            const localVarPath = `/auth/registration/check/username`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckUsernameBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegistrationRegisterBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: RegistrationRegisterBody, options: any = {}): FetchArgs {
            const localVarPath = `/auth/registration/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegistrationRegisterBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend email verification
         * @param {RegistrationResendverificationBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationMail(body?: RegistrationResendverificationBody, options: any = {}): FetchArgs {
            const localVarPath = `/auth/registration/resend-verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegistrationResendverificationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify the email address
         * @param {string} token1 
         * @param {string} token2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token1: string, token2: string, options: any = {}): FetchArgs {
            // verify required parameter 'token1' is not null or undefined
            if (token1 === null || token1 === undefined) {
                throw new RequiredError('token1','Required parameter token1 was null or undefined when calling verifyEmail.');
            }
            // verify required parameter 'token2' is not null or undefined
            if (token2 === null || token2 === undefined) {
                throw new RequiredError('token2','Required parameter token2 was null or undefined when calling verifyEmail.');
            }
            const localVarPath = `/auth/registration/verify/email/{token1}/{token2}`
                .replace(`{${"token1"}}`, encodeURIComponent(String(token1)))
                .replace(`{${"token2"}}`, encodeURIComponent(String(token2)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthServiceRegistrationApi - functional programming interface
 * @export
 */
export const AuthServiceRegistrationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if the email is already taken or not
         * @param {CheckEmailBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEmail(body?: CheckEmailBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AuthServiceRegistrationApiFetchParamCreator(configuration).checkEmail(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check if the username is already taken or not
         * @param {CheckUsernameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(body?: CheckUsernameBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AuthServiceRegistrationApiFetchParamCreator(configuration).checkUsername(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegistrationRegisterBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: RegistrationRegisterBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AuthServiceRegistrationApiFetchParamCreator(configuration).register(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resend email verification
         * @param {RegistrationResendverificationBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationMail(body?: RegistrationResendverificationBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AuthServiceRegistrationApiFetchParamCreator(configuration).resendVerificationMail(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Verify the email address
         * @param {string} token1 
         * @param {string} token2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token1: string, token2: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = AuthServiceRegistrationApiFetchParamCreator(configuration).verifyEmail(token1, token2, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthServiceRegistrationApi - factory interface
 * @export
 */
export const AuthServiceRegistrationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Check if the email is already taken or not
         * @param {CheckEmailBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEmail(body?: CheckEmailBody, options?: any) {
            return AuthServiceRegistrationApiFp(configuration).checkEmail(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check if the username is already taken or not
         * @param {CheckUsernameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUsername(body?: CheckUsernameBody, options?: any) {
            return AuthServiceRegistrationApiFp(configuration).checkUsername(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {RegistrationRegisterBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: RegistrationRegisterBody, options?: any) {
            return AuthServiceRegistrationApiFp(configuration).register(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resend email verification
         * @param {RegistrationResendverificationBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationMail(body?: RegistrationResendverificationBody, options?: any) {
            return AuthServiceRegistrationApiFp(configuration).resendVerificationMail(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Verify the email address
         * @param {string} token1 
         * @param {string} token2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token1: string, token2: string, options?: any) {
            return AuthServiceRegistrationApiFp(configuration).verifyEmail(token1, token2, options)(fetch, basePath);
        },
    };
};

/**
 * AuthServiceRegistrationApi - object-oriented interface
 * @export
 * @class AuthServiceRegistrationApi
 * @extends {BaseAPI}
 */
export class AuthServiceRegistrationApi extends BaseAPI {
    /**
     * 
     * @summary Check if the email is already taken or not
     * @param {CheckEmailBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceRegistrationApi
     */
    public checkEmail(body?: CheckEmailBody, options?: any) {
        return AuthServiceRegistrationApiFp(this.configuration).checkEmail(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check if the username is already taken or not
     * @param {CheckUsernameBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceRegistrationApi
     */
    public checkUsername(body?: CheckUsernameBody, options?: any) {
        return AuthServiceRegistrationApiFp(this.configuration).checkUsername(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Register a new user
     * @param {RegistrationRegisterBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceRegistrationApi
     */
    public register(body?: RegistrationRegisterBody, options?: any) {
        return AuthServiceRegistrationApiFp(this.configuration).register(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resend email verification
     * @param {RegistrationResendverificationBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceRegistrationApi
     */
    public resendVerificationMail(body?: RegistrationResendverificationBody, options?: any) {
        return AuthServiceRegistrationApiFp(this.configuration).resendVerificationMail(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Verify the email address
     * @param {string} token1 
     * @param {string} token2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceRegistrationApi
     */
    public verifyEmail(token1: string, token2: string, options?: any) {
        return AuthServiceRegistrationApiFp(this.configuration).verifyEmail(token1, token2, options)(this.fetch, this.basePath);
    }

}
/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export const CollectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add item to 'for later' collection
         * @param {string} type 
         * @param {CollectionsLaterBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemForLater(type: string, body?: CollectionsLaterBody, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling addItemForLater.');
            }
            const localVarPath = `/collections/later`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollectionsLaterBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add item(s) to specific collection
         * @param {number} collectionId 
         * @param {string} type 
         * @param {CollectionIdItemsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToCollection(collectionId: number, type: string, body?: CollectionIdItemsBody, options: any = {}): FetchArgs {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling addItemToCollection.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling addItemToCollection.');
            }
            const localVarPath = `/collections/{collectionId}/items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollectionIdItemsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a collection
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling collectionsIdDelete.');
            }
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new collection
         * @param {CollectionsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body?: CollectionsCreateBody, options: any = {}): FetchArgs {
            const localVarPath = `/collections/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollectionsCreateBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get collection info by collection Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling detail.');
            }
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List where the work saved
         * @param {string} type 
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSaveInfo(type: string, workId: number, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getCurrentSaveInfo.');
            }
            // verify required parameter 'workId' is not null or undefined
            if (workId === null || workId === undefined) {
                throw new RequiredError('workId','Required parameter workId was null or undefined when calling getCurrentSaveInfo.');
            }
            const localVarPath = `/collections/current/{type}/{work_id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"work_id"}}`, encodeURIComponent(String(workId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of collection
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionItems(id: number, perPage: number, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listCollectionItems.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling listCollectionItems.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling listCollectionItems.');
            }
            const localVarPath = `/collections/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List collection owned by user
         * @param {number} userId 
         * @param {string} type 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollections(userId: number, type: string, page: number, perPage: number, name?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserCollections.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling listUserCollections.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling listUserCollections.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling listUserCollections.');
            }
            const localVarPath = `/collections/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove item(s) from specific collection
         * @param {number} collectionId 
         * @param {string} type 
         * @param {CollectionIdItemsBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItemFromCollection(collectionId: number, type: string, body?: CollectionIdItemsBody1, options: any = {}): FetchArgs {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling removeItemFromCollection.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling removeItemFromCollection.');
            }
            const localVarPath = `/collections/{collectionId}/items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollectionIdItemsBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update information of current existing collection
         * @param {CollectionsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(body?: CollectionsBody, options: any = {}): FetchArgs {
            const localVarPath = `/collections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollectionsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add item to 'for later' collection
         * @param {string} type 
         * @param {CollectionsLaterBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemForLater(type: string, body?: CollectionsLaterBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).addItemForLater(type, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add item(s) to specific collection
         * @param {number} collectionId 
         * @param {string} type 
         * @param {CollectionIdItemsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToCollection(collectionId: number, type: string, body?: CollectionIdItemsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).addItemToCollection(collectionId, type, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a collection
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new collection
         * @param {CollectionsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body?: CollectionsCreateBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).create(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get collection info by collection Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CollectionModel> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).detail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List where the work saved
         * @param {string} type 
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSaveInfo(type: string, workId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getCurrentSaveInfo(type, workId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get list of collection
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionItems(id: number, perPage: number, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listCollectionItems(id, perPage, page, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List collection owned by user
         * @param {number} userId 
         * @param {string} type 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollections(userId: number, type: string, page: number, perPage: number, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listUserCollections(userId, type, page, perPage, name, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove item(s) from specific collection
         * @param {number} collectionId 
         * @param {string} type 
         * @param {CollectionIdItemsBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItemFromCollection(collectionId: number, type: string, body?: CollectionIdItemsBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).removeItemFromCollection(collectionId, type, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update information of current existing collection
         * @param {CollectionsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(body?: CollectionsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).updateCollection(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add item to 'for later' collection
         * @param {string} type 
         * @param {CollectionsLaterBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemForLater(type: string, body?: CollectionsLaterBody, options?: any) {
            return CollectionsApiFp(configuration).addItemForLater(type, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add item(s) to specific collection
         * @param {number} collectionId 
         * @param {string} type 
         * @param {CollectionIdItemsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToCollection(collectionId: number, type: string, body?: CollectionIdItemsBody, options?: any) {
            return CollectionsApiFp(configuration).addItemToCollection(collectionId, type, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a collection
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsIdDelete(id: number, options?: any) {
            return CollectionsApiFp(configuration).collectionsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new collection
         * @param {CollectionsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(body?: CollectionsCreateBody, options?: any) {
            return CollectionsApiFp(configuration).create(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get collection info by collection Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detail(id: number, options?: any) {
            return CollectionsApiFp(configuration).detail(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List where the work saved
         * @param {string} type 
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSaveInfo(type: string, workId: number, options?: any) {
            return CollectionsApiFp(configuration).getCurrentSaveInfo(type, workId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get list of collection
         * @param {number} id 
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionItems(id: number, perPage: number, page: number, options?: any) {
            return CollectionsApiFp(configuration).listCollectionItems(id, perPage, page, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List collection owned by user
         * @param {number} userId 
         * @param {string} type 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCollections(userId: number, type: string, page: number, perPage: number, name?: string, options?: any) {
            return CollectionsApiFp(configuration).listUserCollections(userId, type, page, perPage, name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove item(s) from specific collection
         * @param {number} collectionId 
         * @param {string} type 
         * @param {CollectionIdItemsBody1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItemFromCollection(collectionId: number, type: string, body?: CollectionIdItemsBody1, options?: any) {
            return CollectionsApiFp(configuration).removeItemFromCollection(collectionId, type, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update information of current existing collection
         * @param {CollectionsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(body?: CollectionsBody, options?: any) {
            return CollectionsApiFp(configuration).updateCollection(body, options)(fetch, basePath);
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * 
     * @summary Add item to 'for later' collection
     * @param {string} type 
     * @param {CollectionsLaterBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public addItemForLater(type: string, body?: CollectionsLaterBody, options?: any) {
        return CollectionsApiFp(this.configuration).addItemForLater(type, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add item(s) to specific collection
     * @param {number} collectionId 
     * @param {string} type 
     * @param {CollectionIdItemsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public addItemToCollection(collectionId: number, type: string, body?: CollectionIdItemsBody, options?: any) {
        return CollectionsApiFp(this.configuration).addItemToCollection(collectionId, type, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a collection
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsIdDelete(id: number, options?: any) {
        return CollectionsApiFp(this.configuration).collectionsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new collection
     * @param {CollectionsCreateBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public create(body?: CollectionsCreateBody, options?: any) {
        return CollectionsApiFp(this.configuration).create(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get collection info by collection Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public detail(id: number, options?: any) {
        return CollectionsApiFp(this.configuration).detail(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List where the work saved
     * @param {string} type 
     * @param {number} workId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCurrentSaveInfo(type: string, workId: number, options?: any) {
        return CollectionsApiFp(this.configuration).getCurrentSaveInfo(type, workId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get list of collection
     * @param {number} id 
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listCollectionItems(id: number, perPage: number, page: number, options?: any) {
        return CollectionsApiFp(this.configuration).listCollectionItems(id, perPage, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List collection owned by user
     * @param {number} userId 
     * @param {string} type 
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listUserCollections(userId: number, type: string, page: number, perPage: number, name?: string, options?: any) {
        return CollectionsApiFp(this.configuration).listUserCollections(userId, type, page, perPage, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove item(s) from specific collection
     * @param {number} collectionId 
     * @param {string} type 
     * @param {CollectionIdItemsBody1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public removeItemFromCollection(collectionId: number, type: string, body?: CollectionIdItemsBody1, options?: any) {
        return CollectionsApiFp(this.configuration).removeItemFromCollection(collectionId, type, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update information of current existing collection
     * @param {CollectionsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public updateCollection(body?: CollectionsBody, options?: any) {
        return CollectionsApiFp(this.configuration).updateCollection(body, options)(this.fetch, this.basePath);
    }

}
/**
 * FeedsApi - fetch parameter creator
 * @export
 */
export const FeedsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Comment to feed post
         * @param {FeedsCommentBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentFeed(body?: FeedsCommentBody, options: any = {}): FetchArgs {
            const localVarPath = `/feeds/comment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FeedsCommentBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create feed post
         * @param {FeedsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeed(body?: FeedsCreateBody, options: any = {}): FetchArgs {
            const localVarPath = `/feeds/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FeedsCreateBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feed detail by ID
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedById(feedId: number, options: any = {}): FetchArgs {
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeedById.');
            }
            const localVarPath = `/feeds/{feedId}`
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication none required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all feed comments
         * @param {number} feedId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedComments(feedId: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling getFeedComments.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getFeedComments.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getFeedComments.');
            }
            const localVarPath = `/feeds/{feedId}/comments`
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get latest updated feeds combined with artwork posts
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(perPage: number, page: number, mode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getFeeds.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getFeeds.');
            }
            const localVarPath = `/feeds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feed posted by specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedsByUserId(userId: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getFeedsByUserId.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getFeedsByUserId.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getFeedsByUserId.');
            }
            const localVarPath = `/feeds/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication none required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get latest feeds from anyone
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestFeeds(page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getLatestFeeds.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getLatestFeeds.');
            }
            const localVarPath = `/feeds/latest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication none required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get latest feeds from anyone
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestFeeds_1(page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getLatestFeeds_1.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getLatestFeeds_1.');
            }
            const localVarPath = `/feeds/following`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Like a feed post
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeFeed(feedId: number, options: any = {}): FetchArgs {
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling likeFeed.');
            }
            const localVarPath = `/feeds/like/{feedId}`
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Like a feed comment
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeFeedComment(commentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling likeFeedComment.');
            }
            const localVarPath = `/feeds/{commentId}/like`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlike a liked feed post
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeFeed(feedId: number, options: any = {}): FetchArgs {
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling unlikeFeed.');
            }
            const localVarPath = `/feeds/unlike/{feedId}`
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlike a liked feed comment
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeFeedComment(commentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling unlikeFeedComment.');
            }
            const localVarPath = `/feeds/{commentId}/unlike`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FeedsUpdateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedPost(body?: FeedsUpdateBody, options: any = {}): FetchArgs {
            const localVarPath = `/feeds/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FeedsUpdateBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedsApi - functional programming interface
 * @export
 */
export const FeedsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Comment to feed post
         * @param {FeedsCommentBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentFeed(body?: FeedsCommentBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2016> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).commentFeed(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create feed post
         * @param {FeedsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeed(body?: FeedsCreateBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2015> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).createFeed(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get feed detail by ID
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedById(feedId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20039> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getFeedById(feedId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all feed comments
         * @param {number} feedId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedComments(feedId: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20037> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getFeedComments(feedId, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get latest updated feeds combined with artwork posts
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(perPage: number, page: number, mode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20038> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getFeeds(perPage, page, mode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get feed posted by specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedsByUserId(userId: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20036> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getFeedsByUserId(userId, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get latest feeds from anyone
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestFeeds(page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20036> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getLatestFeeds(page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get latest feeds from anyone
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestFeeds_1(page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20036> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).getLatestFeeds_1(page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Like a feed post
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeFeed(feedId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).likeFeed(feedId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Like a feed comment
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeFeedComment(commentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).likeFeedComment(commentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unlike a liked feed post
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeFeed(feedId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).unlikeFeed(feedId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unlike a liked feed comment
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeFeedComment(commentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).unlikeFeedComment(commentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {FeedsUpdateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedPost(body?: FeedsUpdateBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2015> {
            const localVarFetchArgs = FeedsApiFetchParamCreator(configuration).updateFeedPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FeedsApi - factory interface
 * @export
 */
export const FeedsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Comment to feed post
         * @param {FeedsCommentBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentFeed(body?: FeedsCommentBody, options?: any) {
            return FeedsApiFp(configuration).commentFeed(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create feed post
         * @param {FeedsCreateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeed(body?: FeedsCreateBody, options?: any) {
            return FeedsApiFp(configuration).createFeed(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get feed detail by ID
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedById(feedId: number, options?: any) {
            return FeedsApiFp(configuration).getFeedById(feedId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all feed comments
         * @param {number} feedId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedComments(feedId: number, page: number, perPage: number, options?: any) {
            return FeedsApiFp(configuration).getFeedComments(feedId, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get latest updated feeds combined with artwork posts
         * @param {number} perPage How many record to show per page of pagination
         * @param {number} page Pagination index
         * @param {string} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(perPage: number, page: number, mode?: string, options?: any) {
            return FeedsApiFp(configuration).getFeeds(perPage, page, mode, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get feed posted by specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedsByUserId(userId: number, page: number, perPage: number, options?: any) {
            return FeedsApiFp(configuration).getFeedsByUserId(userId, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get latest feeds from anyone
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestFeeds(page: number, perPage: number, options?: any) {
            return FeedsApiFp(configuration).getLatestFeeds(page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get latest feeds from anyone
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestFeeds_1(page: number, perPage: number, options?: any) {
            return FeedsApiFp(configuration).getLatestFeeds_1(page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Like a feed post
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeFeed(feedId: number, options?: any) {
            return FeedsApiFp(configuration).likeFeed(feedId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Like a feed comment
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeFeedComment(commentId: number, options?: any) {
            return FeedsApiFp(configuration).likeFeedComment(commentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unlike a liked feed post
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeFeed(feedId: number, options?: any) {
            return FeedsApiFp(configuration).unlikeFeed(feedId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unlike a liked feed comment
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeFeedComment(commentId: number, options?: any) {
            return FeedsApiFp(configuration).unlikeFeedComment(commentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {FeedsUpdateBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedPost(body?: FeedsUpdateBody, options?: any) {
            return FeedsApiFp(configuration).updateFeedPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * FeedsApi - object-oriented interface
 * @export
 * @class FeedsApi
 * @extends {BaseAPI}
 */
export class FeedsApi extends BaseAPI {
    /**
     * 
     * @summary Comment to feed post
     * @param {FeedsCommentBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public commentFeed(body?: FeedsCommentBody, options?: any) {
        return FeedsApiFp(this.configuration).commentFeed(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create feed post
     * @param {FeedsCreateBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public createFeed(body?: FeedsCreateBody, options?: any) {
        return FeedsApiFp(this.configuration).createFeed(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get feed detail by ID
     * @param {number} feedId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public getFeedById(feedId: number, options?: any) {
        return FeedsApiFp(this.configuration).getFeedById(feedId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all feed comments
     * @param {number} feedId 
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public getFeedComments(feedId: number, page: number, perPage: number, options?: any) {
        return FeedsApiFp(this.configuration).getFeedComments(feedId, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get latest updated feeds combined with artwork posts
     * @param {number} perPage How many record to show per page of pagination
     * @param {number} page Pagination index
     * @param {string} [mode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public getFeeds(perPage: number, page: number, mode?: string, options?: any) {
        return FeedsApiFp(this.configuration).getFeeds(perPage, page, mode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get feed posted by specific user
     * @param {number} userId 
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public getFeedsByUserId(userId: number, page: number, perPage: number, options?: any) {
        return FeedsApiFp(this.configuration).getFeedsByUserId(userId, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get latest feeds from anyone
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public getLatestFeeds(page: number, perPage: number, options?: any) {
        return FeedsApiFp(this.configuration).getLatestFeeds(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get latest feeds from anyone
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public getLatestFeeds_1(page: number, perPage: number, options?: any) {
        return FeedsApiFp(this.configuration).getLatestFeeds_1(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Like a feed post
     * @param {number} feedId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public likeFeed(feedId: number, options?: any) {
        return FeedsApiFp(this.configuration).likeFeed(feedId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Like a feed comment
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public likeFeedComment(commentId: number, options?: any) {
        return FeedsApiFp(this.configuration).likeFeedComment(commentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unlike a liked feed post
     * @param {number} feedId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public unlikeFeed(feedId: number, options?: any) {
        return FeedsApiFp(this.configuration).unlikeFeed(feedId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unlike a liked feed comment
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public unlikeFeedComment(commentId: number, options?: any) {
        return FeedsApiFp(this.configuration).unlikeFeedComment(commentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {FeedsUpdateBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public updateFeedPost(body?: FeedsUpdateBody, options?: any) {
        return FeedsApiFp(this.configuration).updateFeedPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsArtworksCommentsApi - fetch parameter creator
 * @export
 */
export const NotificationsArtworksCommentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear/delete all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllArtworkCommentAndReplyNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/comments-and-replies/clear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user artwork comment liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the comment will be displayed as &#x27;other X people liked your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentLikedNotifications(showLimit: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'showLimit' is not null or undefined
            if (showLimit === null || showLimit === undefined) {
                throw new RequiredError('showLimit','Required parameter showLimit was null or undefined when calling getArtworkCommentLikedNotifications.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getArtworkCommentLikedNotifications.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getArtworkCommentLikedNotifications.');
            }
            const localVarPath = `/notifications/artworks/comments/liked`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (showLimit !== undefined) {
                localVarQueryParameter['show_limit'] = showLimit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user artwork comment notifications
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentNotifications(page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getArtworkCommentNotifications.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getArtworkCommentNotifications.');
            }
            const localVarPath = `/notifications/artworks/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artwork comment reply liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people replied to your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyLikedNotifications(showLimit: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'showLimit' is not null or undefined
            if (showLimit === null || showLimit === undefined) {
                throw new RequiredError('showLimit','Required parameter showLimit was null or undefined when calling getArtworkCommentReplyLikedNotifications.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getArtworkCommentReplyLikedNotifications.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getArtworkCommentReplyLikedNotifications.');
            }
            const localVarPath = `/notifications/artworks/comment/replies/liked`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (showLimit !== undefined) {
                localVarQueryParameter['show_limit'] = showLimit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artwork comment reply notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who replied to your comment will be displayed as &#x27;other X people replied to your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyNotifications(showLimit: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'showLimit' is not null or undefined
            if (showLimit === null || showLimit === undefined) {
                throw new RequiredError('showLimit','Required parameter showLimit was null or undefined when calling getArtworkCommentReplyNotifications.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getArtworkCommentReplyNotifications.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getArtworkCommentReplyNotifications.');
            }
            const localVarPath = `/notifications/artworks/comment/replies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (showLimit !== undefined) {
                localVarQueryParameter['show_limit'] = showLimit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark specific artwork comment like notification as read
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentLikeNotificationAsRead(commentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling markArtworkCommentLikeNotificationAsRead.');
            }
            const localVarPath = `/notifications/artworks/comments/liked/read/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark specific artwork comment notification as read
         * @param {number} workId 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentNotificationAsRead(workId: number, commentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'workId' is not null or undefined
            if (workId === null || workId === undefined) {
                throw new RequiredError('workId','Required parameter workId was null or undefined when calling markArtworkCommentNotificationAsRead.');
            }
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling markArtworkCommentNotificationAsRead.');
            }
            const localVarPath = `/notifications/artworks/comments/read/{workId}/{commentId}`
                .replace(`{${"workId"}}`, encodeURIComponent(String(workId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark specific artwork comment reply notification as read
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentReplyNotificationAsRead(commentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling markArtworkCommentReplyNotificationAsRead.');
            }
            const localVarPath = `/notifications/artworks/comment/replies/read/{commentId}`
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllArtworkCommentAndReplyNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/comments-and-replies/read/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsArtworksCommentsApi - functional programming interface
 * @export
 */
export const NotificationsArtworksCommentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear/delete all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllArtworkCommentAndReplyNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).clearAllArtworkCommentAndReplyNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user artwork comment liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the comment will be displayed as &#x27;other X people liked your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentLikedNotifications(showLimit: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20031> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).getArtworkCommentLikedNotifications(showLimit, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user artwork comment notifications
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentNotifications(page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20030> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).getArtworkCommentNotifications(page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get artwork comment reply liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people replied to your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyLikedNotifications(showLimit: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20033> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).getArtworkCommentReplyLikedNotifications(showLimit, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get artwork comment reply notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who replied to your comment will be displayed as &#x27;other X people replied to your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyNotifications(showLimit: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20032> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).getArtworkCommentReplyNotifications(showLimit, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark specific artwork comment like notification as read
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentLikeNotificationAsRead(commentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).markArtworkCommentLikeNotificationAsRead(commentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark specific artwork comment notification as read
         * @param {number} workId 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentNotificationAsRead(workId: number, commentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).markArtworkCommentNotificationAsRead(workId, commentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark specific artwork comment reply notification as read
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentReplyNotificationAsRead(commentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).markArtworkCommentReplyNotificationAsRead(commentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllArtworkCommentAndReplyNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksCommentsApiFetchParamCreator(configuration).readAllArtworkCommentAndReplyNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsArtworksCommentsApi - factory interface
 * @export
 */
export const NotificationsArtworksCommentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Clear/delete all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllArtworkCommentAndReplyNotifications(options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).clearAllArtworkCommentAndReplyNotifications(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user artwork comment liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the comment will be displayed as &#x27;other X people liked your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentLikedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).getArtworkCommentLikedNotifications(showLimit, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user artwork comment notifications
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentNotifications(page: number, perPage: number, options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).getArtworkCommentNotifications(page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get artwork comment reply liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people replied to your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyLikedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).getArtworkCommentReplyLikedNotifications(showLimit, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get artwork comment reply notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who replied to your comment will be displayed as &#x27;other X people replied to your comment&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyNotifications(showLimit: number, page: number, perPage: number, options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).getArtworkCommentReplyNotifications(showLimit, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark specific artwork comment like notification as read
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentLikeNotificationAsRead(commentId: number, options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).markArtworkCommentLikeNotificationAsRead(commentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark specific artwork comment notification as read
         * @param {number} workId 
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentNotificationAsRead(workId: number, commentId: number, options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).markArtworkCommentNotificationAsRead(workId, commentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark specific artwork comment reply notification as read
         * @param {number} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkCommentReplyNotificationAsRead(commentId: number, options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).markArtworkCommentReplyNotificationAsRead(commentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllArtworkCommentAndReplyNotifications(options?: any) {
            return NotificationsArtworksCommentsApiFp(configuration).readAllArtworkCommentAndReplyNotifications(options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsArtworksCommentsApi - object-oriented interface
 * @export
 * @class NotificationsArtworksCommentsApi
 * @extends {BaseAPI}
 */
export class NotificationsArtworksCommentsApi extends BaseAPI {
    /**
     * 
     * @summary Clear/delete all artwork comment related notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public clearAllArtworkCommentAndReplyNotifications(options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).clearAllArtworkCommentAndReplyNotifications(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user artwork comment liked notifications
     * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the comment will be displayed as &#x27;other X people liked your comment&#x27;
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public getArtworkCommentLikedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).getArtworkCommentLikedNotifications(showLimit, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user artwork comment notifications
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public getArtworkCommentNotifications(page: number, perPage: number, options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).getArtworkCommentNotifications(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get artwork comment reply liked notifications
     * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people replied to your comment&#x27;
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public getArtworkCommentReplyLikedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).getArtworkCommentReplyLikedNotifications(showLimit, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get artwork comment reply notifications
     * @param {number} showLimit Determine how many user to show on each notification, the rest user who replied to your comment will be displayed as &#x27;other X people replied to your comment&#x27;
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public getArtworkCommentReplyNotifications(showLimit: number, page: number, perPage: number, options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).getArtworkCommentReplyNotifications(showLimit, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark specific artwork comment like notification as read
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public markArtworkCommentLikeNotificationAsRead(commentId: number, options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).markArtworkCommentLikeNotificationAsRead(commentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark specific artwork comment notification as read
     * @param {number} workId 
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public markArtworkCommentNotificationAsRead(workId: number, commentId: number, options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).markArtworkCommentNotificationAsRead(workId, commentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark specific artwork comment reply notification as read
     * @param {number} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public markArtworkCommentReplyNotificationAsRead(commentId: number, options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).markArtworkCommentReplyNotificationAsRead(commentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read all artwork comment related notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksCommentsApi
     */
    public readAllArtworkCommentAndReplyNotifications(options?: any) {
        return NotificationsArtworksCommentsApiFp(this.configuration).readAllArtworkCommentAndReplyNotifications(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsArtworksLikesApi - fetch parameter creator
 * @export
 */
export const NotificationsArtworksLikesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear/delete all artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllArtworkLikeNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/liked/clear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notification when artwork liked by other users, auth token required.
         * @summary Get artwork liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkLikedNotifications(showLimit: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'showLimit' is not null or undefined
            if (showLimit === null || showLimit === undefined) {
                throw new RequiredError('showLimit','Required parameter showLimit was null or undefined when calling getArtworkLikedNotifications.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getArtworkLikedNotifications.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getArtworkLikedNotifications.');
            }
            const localVarPath = `/notifications/artworks/liked`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (showLimit !== undefined) {
                localVarQueryParameter['show_limit'] = showLimit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark specific artwork like notification as read
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkLikeNotificationAsRead(workId: number, options: any = {}): FetchArgs {
            // verify required parameter 'workId' is not null or undefined
            if (workId === null || workId === undefined) {
                throw new RequiredError('workId','Required parameter workId was null or undefined when calling markArtworkLikeNotificationAsRead.');
            }
            const localVarPath = `/notifications/artworks/liked/read/{workId}`
                .replace(`{${"workId"}}`, encodeURIComponent(String(workId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read all artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllArtworkLikeNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/liked/read/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsArtworksLikesApi - functional programming interface
 * @export
 */
export const NotificationsArtworksLikesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear/delete all artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllArtworkLikeNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksLikesApiFetchParamCreator(configuration).clearAllArtworkLikeNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get notification when artwork liked by other users, auth token required.
         * @summary Get artwork liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkLikedNotifications(showLimit: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = NotificationsArtworksLikesApiFetchParamCreator(configuration).getArtworkLikedNotifications(showLimit, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark specific artwork like notification as read
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkLikeNotificationAsRead(workId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksLikesApiFetchParamCreator(configuration).markArtworkLikeNotificationAsRead(workId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read all artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllArtworkLikeNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsArtworksLikesApiFetchParamCreator(configuration).readAllArtworkLikeNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsArtworksLikesApi - factory interface
 * @export
 */
export const NotificationsArtworksLikesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Clear/delete all artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllArtworkLikeNotifications(options?: any) {
            return NotificationsArtworksLikesApiFp(configuration).clearAllArtworkLikeNotifications(options)(fetch, basePath);
        },
        /**
         * Get notification when artwork liked by other users, auth token required.
         * @summary Get artwork liked notifications
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkLikedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
            return NotificationsArtworksLikesApiFp(configuration).getArtworkLikedNotifications(showLimit, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark specific artwork like notification as read
         * @param {number} workId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markArtworkLikeNotificationAsRead(workId: number, options?: any) {
            return NotificationsArtworksLikesApiFp(configuration).markArtworkLikeNotificationAsRead(workId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read all artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllArtworkLikeNotifications(options?: any) {
            return NotificationsArtworksLikesApiFp(configuration).readAllArtworkLikeNotifications(options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsArtworksLikesApi - object-oriented interface
 * @export
 * @class NotificationsArtworksLikesApi
 * @extends {BaseAPI}
 */
export class NotificationsArtworksLikesApi extends BaseAPI {
    /**
     * 
     * @summary Clear/delete all artwork like notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksLikesApi
     */
    public clearAllArtworkLikeNotifications(options?: any) {
        return NotificationsArtworksLikesApiFp(this.configuration).clearAllArtworkLikeNotifications(options)(this.fetch, this.basePath);
    }

    /**
     * Get notification when artwork liked by other users, auth token required.
     * @summary Get artwork liked notifications
     * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksLikesApi
     */
    public getArtworkLikedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
        return NotificationsArtworksLikesApiFp(this.configuration).getArtworkLikedNotifications(showLimit, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark specific artwork like notification as read
     * @param {number} workId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksLikesApi
     */
    public markArtworkLikeNotificationAsRead(workId: number, options?: any) {
        return NotificationsArtworksLikesApiFp(this.configuration).markArtworkLikeNotificationAsRead(workId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read all artwork like notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsArtworksLikesApi
     */
    public readAllArtworkLikeNotifications(options?: any) {
        return NotificationsArtworksLikesApiFp(this.configuration).readAllArtworkLikeNotifications(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsFeedsApi - fetch parameter creator
 * @export
 */
export const NotificationsFeedsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear all feed notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllFeedNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/feeds/clear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get notification for feed module
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedNotifications(showLimit: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'showLimit' is not null or undefined
            if (showLimit === null || showLimit === undefined) {
                throw new RequiredError('showLimit','Required parameter showLimit was null or undefined when calling getFeedNotifications.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getFeedNotifications.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getFeedNotifications.');
            }
            const localVarPath = `/notifications/feeds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (showLimit !== undefined) {
                localVarQueryParameter['show_limit'] = showLimit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark all feed notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllFeedNotificationsAsRead(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/feeds/read/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark specific feed notification as read
         * @param {string} type 
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFeedNotificationAsRead(type: string, feedId: number, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling markFeedNotificationAsRead.');
            }
            // verify required parameter 'feedId' is not null or undefined
            if (feedId === null || feedId === undefined) {
                throw new RequiredError('feedId','Required parameter feedId was null or undefined when calling markFeedNotificationAsRead.');
            }
            const localVarPath = `/notifications/feeds/read/{type}/{feedId}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsFeedsApi - functional programming interface
 * @export
 */
export const NotificationsFeedsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear all feed notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllFeedNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = NotificationsFeedsApiFetchParamCreator(configuration).clearAllFeedNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get notification for feed module
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedNotifications(showLimit: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20035> {
            const localVarFetchArgs = NotificationsFeedsApiFetchParamCreator(configuration).getFeedNotifications(showLimit, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark all feed notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllFeedNotificationsAsRead(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = NotificationsFeedsApiFetchParamCreator(configuration).markAllFeedNotificationsAsRead(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark specific feed notification as read
         * @param {string} type 
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFeedNotificationAsRead(type: string, feedId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = NotificationsFeedsApiFetchParamCreator(configuration).markFeedNotificationAsRead(type, feedId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsFeedsApi - factory interface
 * @export
 */
export const NotificationsFeedsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Clear all feed notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearAllFeedNotifications(options?: any) {
            return NotificationsFeedsApiFp(configuration).clearAllFeedNotifications(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get notification for feed module
         * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
            return NotificationsFeedsApiFp(configuration).getFeedNotifications(showLimit, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark all feed notifications as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllFeedNotificationsAsRead(options?: any) {
            return NotificationsFeedsApiFp(configuration).markAllFeedNotificationsAsRead(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark specific feed notification as read
         * @param {string} type 
         * @param {number} feedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFeedNotificationAsRead(type: string, feedId: number, options?: any) {
            return NotificationsFeedsApiFp(configuration).markFeedNotificationAsRead(type, feedId, options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsFeedsApi - object-oriented interface
 * @export
 * @class NotificationsFeedsApi
 * @extends {BaseAPI}
 */
export class NotificationsFeedsApi extends BaseAPI {
    /**
     * 
     * @summary Clear all feed notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsFeedsApi
     */
    public clearAllFeedNotifications(options?: any) {
        return NotificationsFeedsApiFp(this.configuration).clearAllFeedNotifications(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get notification for feed module
     * @param {number} showLimit Determine how many user to show on each notification, the rest user who liked the artwork will be displayed as &#x27;other X people liked your artwork&#x27;
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsFeedsApi
     */
    public getFeedNotifications(showLimit: number, page: number, perPage: number, options?: any) {
        return NotificationsFeedsApiFp(this.configuration).getFeedNotifications(showLimit, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark all feed notifications as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsFeedsApi
     */
    public markAllFeedNotificationsAsRead(options?: any) {
        return NotificationsFeedsApiFp(this.configuration).markAllFeedNotificationsAsRead(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark specific feed notification as read
     * @param {string} type 
     * @param {number} feedId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsFeedsApi
     */
    public markFeedNotificationAsRead(type: string, feedId: number, options?: any) {
        return NotificationsFeedsApiFp(this.configuration).markFeedNotificationAsRead(type, feedId, options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsMarkersApi - fetch parameter creator
 * @export
 */
export const NotificationsMarkersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear all notification counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearMarkers(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/marker/clear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return how many unexpanded all notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkers(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsMarkersApi - functional programming interface
 * @export
 */
export const NotificationsMarkersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear all notification counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearMarkers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsMarkersApiFetchParamCreator(configuration).clearMarkers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return how many unexpanded all notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersApiFetchParamCreator(configuration).getMarkers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsMarkersApi - factory interface
 * @export
 */
export const NotificationsMarkersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Clear all notification counter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearMarkers(options?: any) {
            return NotificationsMarkersApiFp(configuration).clearMarkers(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return how many unexpanded all notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkers(options?: any) {
            return NotificationsMarkersApiFp(configuration).getMarkers(options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsMarkersApi - object-oriented interface
 * @export
 * @class NotificationsMarkersApi
 * @extends {BaseAPI}
 */
export class NotificationsMarkersApi extends BaseAPI {
    /**
     * 
     * @summary Clear all notification counter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersApi
     */
    public clearMarkers(options?: any) {
        return NotificationsMarkersApiFp(this.configuration).clearMarkers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return how many unexpanded all notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersApi
     */
    public getMarkers(options?: any) {
        return NotificationsMarkersApiFp(this.configuration).getMarkers(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsMarkersArtworksApi - fetch parameter creator
 * @export
 */
export const NotificationsMarkersArtworksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return how many unexpanded artwork comment liked notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentLikedMarker(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/comments/liked/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentMarker(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/comments/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment reply notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentRepliesMarker(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/comments/replies/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment reply like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyLikesMarker(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/comments/replies/liked/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return how many unexpanded all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentsAndRepliesMarker(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/comments-and-replies/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkLikeMarker(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/artworks/liked/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsMarkersArtworksApi - functional programming interface
 * @export
 */
export const NotificationsMarkersArtworksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return how many unexpanded artwork comment liked notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentLikedMarker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersArtworksApiFetchParamCreator(configuration).getArtworkCommentLikedMarker(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentMarker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersArtworksApiFetchParamCreator(configuration).getArtworkCommentMarker(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment reply notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentRepliesMarker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersArtworksApiFetchParamCreator(configuration).getArtworkCommentRepliesMarker(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment reply like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyLikesMarker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersArtworksApiFetchParamCreator(configuration).getArtworkCommentReplyLikesMarker(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return how many unexpanded all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentsAndRepliesMarker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersArtworksApiFetchParamCreator(configuration).getArtworkCommentsAndRepliesMarker(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return how many unexpanded artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkLikeMarker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersArtworksApiFetchParamCreator(configuration).getArtworkLikeMarker(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsMarkersArtworksApi - factory interface
 * @export
 */
export const NotificationsMarkersArtworksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Return how many unexpanded artwork comment liked notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentLikedMarker(options?: any) {
            return NotificationsMarkersArtworksApiFp(configuration).getArtworkCommentLikedMarker(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentMarker(options?: any) {
            return NotificationsMarkersArtworksApiFp(configuration).getArtworkCommentMarker(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment reply notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentRepliesMarker(options?: any) {
            return NotificationsMarkersArtworksApiFp(configuration).getArtworkCommentRepliesMarker(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return how many unexpanded artwork comment reply like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentReplyLikesMarker(options?: any) {
            return NotificationsMarkersArtworksApiFp(configuration).getArtworkCommentReplyLikesMarker(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return how many unexpanded all artwork comment related notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkCommentsAndRepliesMarker(options?: any) {
            return NotificationsMarkersArtworksApiFp(configuration).getArtworkCommentsAndRepliesMarker(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return how many unexpanded artwork like notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkLikeMarker(options?: any) {
            return NotificationsMarkersArtworksApiFp(configuration).getArtworkLikeMarker(options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsMarkersArtworksApi - object-oriented interface
 * @export
 * @class NotificationsMarkersArtworksApi
 * @extends {BaseAPI}
 */
export class NotificationsMarkersArtworksApi extends BaseAPI {
    /**
     * 
     * @summary Return how many unexpanded artwork comment liked notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersArtworksApi
     */
    public getArtworkCommentLikedMarker(options?: any) {
        return NotificationsMarkersArtworksApiFp(this.configuration).getArtworkCommentLikedMarker(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return how many unexpanded artwork comment notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersArtworksApi
     */
    public getArtworkCommentMarker(options?: any) {
        return NotificationsMarkersArtworksApiFp(this.configuration).getArtworkCommentMarker(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return how many unexpanded artwork comment reply notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersArtworksApi
     */
    public getArtworkCommentRepliesMarker(options?: any) {
        return NotificationsMarkersArtworksApiFp(this.configuration).getArtworkCommentRepliesMarker(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return how many unexpanded artwork comment reply like notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersArtworksApi
     */
    public getArtworkCommentReplyLikesMarker(options?: any) {
        return NotificationsMarkersArtworksApiFp(this.configuration).getArtworkCommentReplyLikesMarker(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return how many unexpanded all artwork comment related notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersArtworksApi
     */
    public getArtworkCommentsAndRepliesMarker(options?: any) {
        return NotificationsMarkersArtworksApiFp(this.configuration).getArtworkCommentsAndRepliesMarker(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return how many unexpanded artwork like notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersArtworksApi
     */
    public getArtworkLikeMarker(options?: any) {
        return NotificationsMarkersArtworksApiFp(this.configuration).getArtworkLikeMarker(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsMarkersFeedsApi - fetch parameter creator
 * @export
 */
export const NotificationsMarkersFeedsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary return how many unexpanded feed notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFeedNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/feeds/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsMarkersFeedsApi - functional programming interface
 * @export
 */
export const NotificationsMarkersFeedsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary return how many unexpanded feed notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFeedNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersFeedsApiFetchParamCreator(configuration).countFeedNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsMarkersFeedsApi - factory interface
 * @export
 */
export const NotificationsMarkersFeedsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary return how many unexpanded feed notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFeedNotifications(options?: any) {
            return NotificationsMarkersFeedsApiFp(configuration).countFeedNotifications(options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsMarkersFeedsApi - object-oriented interface
 * @export
 * @class NotificationsMarkersFeedsApi
 * @extends {BaseAPI}
 */
export class NotificationsMarkersFeedsApi extends BaseAPI {
    /**
     * 
     * @summary return how many unexpanded feed notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersFeedsApi
     */
    public countFeedNotifications(options?: any) {
        return NotificationsMarkersFeedsApiFp(this.configuration).countFeedNotifications(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsMarkersUsersApi - fetch parameter creator
 * @export
 */
export const NotificationsMarkersUsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return how many unexpanded user follow notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowMarker(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/users/follow/marker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsMarkersUsersApi - functional programming interface
 * @export
 */
export const NotificationsMarkersUsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return how many unexpanded user follow notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowMarker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = NotificationsMarkersUsersApiFetchParamCreator(configuration).getUserFollowMarker(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsMarkersUsersApi - factory interface
 * @export
 */
export const NotificationsMarkersUsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Return how many unexpanded user follow notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowMarker(options?: any) {
            return NotificationsMarkersUsersApiFp(configuration).getUserFollowMarker(options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsMarkersUsersApi - object-oriented interface
 * @export
 * @class NotificationsMarkersUsersApi
 * @extends {BaseAPI}
 */
export class NotificationsMarkersUsersApi extends BaseAPI {
    /**
     * 
     * @summary Return how many unexpanded user follow notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsMarkersUsersApi
     */
    public getUserFollowMarker(options?: any) {
        return NotificationsMarkersUsersApiFp(this.configuration).getUserFollowMarker(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsUsersApi - fetch parameter creator
 * @export
 */
export const NotificationsUsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear all user follow notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUserFollowNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/users/follow/clear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user follow notifications
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowNotifications(page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getUserFollowNotifications.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getUserFollowNotifications.');
            }
            const localVarPath = `/notifications/users/follow`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark all user follow notification as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllUserFollowNotificationAsRead(options: any = {}): FetchArgs {
            const localVarPath = `/notifications/users/follow/read/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark specific user follow notification as read
         * @param {number} followerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserFollowNotificationAsRead(followerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'followerId' is not null or undefined
            if (followerId === null || followerId === undefined) {
                throw new RequiredError('followerId','Required parameter followerId was null or undefined when calling markUserFollowNotificationAsRead.');
            }
            const localVarPath = `/notifications/users/follow/read/{followerId}`
                .replace(`{${"followerId"}}`, encodeURIComponent(String(followerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsUsersApi - functional programming interface
 * @export
 */
export const NotificationsUsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear all user follow notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUserFollowNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsUsersApiFetchParamCreator(configuration).clearUserFollowNotifications(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user follow notifications
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowNotifications(page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20034> {
            const localVarFetchArgs = NotificationsUsersApiFetchParamCreator(configuration).getUserFollowNotifications(page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark all user follow notification as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllUserFollowNotificationAsRead(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsUsersApiFetchParamCreator(configuration).markAllUserFollowNotificationAsRead(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Mark specific user follow notification as read
         * @param {number} followerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserFollowNotificationAsRead(followerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = NotificationsUsersApiFetchParamCreator(configuration).markUserFollowNotificationAsRead(followerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsUsersApi - factory interface
 * @export
 */
export const NotificationsUsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Clear all user follow notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUserFollowNotifications(options?: any) {
            return NotificationsUsersApiFp(configuration).clearUserFollowNotifications(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user follow notifications
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowNotifications(page: number, perPage: number, options?: any) {
            return NotificationsUsersApiFp(configuration).getUserFollowNotifications(page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark all user follow notification as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllUserFollowNotificationAsRead(options?: any) {
            return NotificationsUsersApiFp(configuration).markAllUserFollowNotificationAsRead(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Mark specific user follow notification as read
         * @param {number} followerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserFollowNotificationAsRead(followerId: number, options?: any) {
            return NotificationsUsersApiFp(configuration).markUserFollowNotificationAsRead(followerId, options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsUsersApi - object-oriented interface
 * @export
 * @class NotificationsUsersApi
 * @extends {BaseAPI}
 */
export class NotificationsUsersApi extends BaseAPI {
    /**
     * 
     * @summary Clear all user follow notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsUsersApi
     */
    public clearUserFollowNotifications(options?: any) {
        return NotificationsUsersApiFp(this.configuration).clearUserFollowNotifications(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user follow notifications
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsUsersApi
     */
    public getUserFollowNotifications(page: number, perPage: number, options?: any) {
        return NotificationsUsersApiFp(this.configuration).getUserFollowNotifications(page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark all user follow notification as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsUsersApi
     */
    public markAllUserFollowNotificationAsRead(options?: any) {
        return NotificationsUsersApiFp(this.configuration).markAllUserFollowNotificationAsRead(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Mark specific user follow notification as read
     * @param {number} followerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsUsersApi
     */
    public markUserFollowNotificationAsRead(followerId: number, options?: any) {
        return NotificationsUsersApiFp(this.configuration).markUserFollowNotificationAsRead(followerId, options)(this.fetch, this.basePath);
    }

}
/**
 * ReportsApi - fetch parameter creator
 * @export
 */
export const ReportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new report
         * @param {ReportsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewReport(body?: ReportsBody, options: any = {}): FetchArgs {
            const localVarPath = `/reports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get report detail by report ID
         * @param {number} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportById(reportId: number, options: any = {}): FetchArgs {
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new RequiredError('reportId','Required parameter reportId was null or undefined when calling getReportById.');
            }
            const localVarPath = `/reports/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get report status/progress of post
         * @param {string} type 
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportStatus(type: string, postId: number, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getReportStatus.');
            }
            // verify required parameter 'postId' is not null or undefined
            if (postId === null || postId === undefined) {
                throw new RequiredError('postId','Required parameter postId was null or undefined when calling getReportStatus.');
            }
            const localVarPath = `/reports/status/{type}/{postId}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get report list
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [status] 
         * @param {string} [createdAtFrom] 
         * @param {string} [createdAtTo] 
         * @param {number} [userId] 
         * @param {string} [reasons] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(page: number, perPage: number, status?: string, createdAtFrom?: string, createdAtTo?: string, userId?: number, reasons?: string, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getReports.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling getReports.');
            }
            const localVarPath = `/reports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['created_at_from'] = createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['created_at_to'] = createdAtTo;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (reasons !== undefined) {
                localVarQueryParameter['reasons'] = reasons;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Review report and give feedback to user who reported it
         * @param {ReportsReviewBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewReport(body?: ReportsReviewBody, options: any = {}): FetchArgs {
            const localVarPath = `/reports/review`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportsReviewBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new report
         * @param {ReportsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewReport(body?: ReportsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2017> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).createNewReport(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get report detail by report ID
         * @param {number} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportById(reportId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2017> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).getReportById(reportId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get report status/progress of post
         * @param {string} type 
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportStatus(type: string, postId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20041> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).getReportStatus(type, postId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get report list
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [status] 
         * @param {string} [createdAtFrom] 
         * @param {string} [createdAtTo] 
         * @param {number} [userId] 
         * @param {string} [reasons] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(page: number, perPage: number, status?: string, createdAtFrom?: string, createdAtTo?: string, userId?: number, reasons?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20040> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).getReports(page, perPage, status, createdAtFrom, createdAtTo, userId, reasons, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Review report and give feedback to user who reported it
         * @param {ReportsReviewBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewReport(body?: ReportsReviewBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).reviewReport(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new report
         * @param {ReportsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewReport(body?: ReportsBody, options?: any) {
            return ReportsApiFp(configuration).createNewReport(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get report detail by report ID
         * @param {number} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportById(reportId: number, options?: any) {
            return ReportsApiFp(configuration).getReportById(reportId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get report status/progress of post
         * @param {string} type 
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportStatus(type: string, postId: number, options?: any) {
            return ReportsApiFp(configuration).getReportStatus(type, postId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get report list
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [status] 
         * @param {string} [createdAtFrom] 
         * @param {string} [createdAtTo] 
         * @param {number} [userId] 
         * @param {string} [reasons] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(page: number, perPage: number, status?: string, createdAtFrom?: string, createdAtTo?: string, userId?: number, reasons?: string, options?: any) {
            return ReportsApiFp(configuration).getReports(page, perPage, status, createdAtFrom, createdAtTo, userId, reasons, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Review report and give feedback to user who reported it
         * @param {ReportsReviewBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewReport(body?: ReportsReviewBody, options?: any) {
            return ReportsApiFp(configuration).reviewReport(body, options)(fetch, basePath);
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new report
     * @param {ReportsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public createNewReport(body?: ReportsBody, options?: any) {
        return ReportsApiFp(this.configuration).createNewReport(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get report detail by report ID
     * @param {number} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportById(reportId: number, options?: any) {
        return ReportsApiFp(this.configuration).getReportById(reportId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get report status/progress of post
     * @param {string} type 
     * @param {number} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportStatus(type: string, postId: number, options?: any) {
        return ReportsApiFp(this.configuration).getReportStatus(type, postId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get report list
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {string} [status] 
     * @param {string} [createdAtFrom] 
     * @param {string} [createdAtTo] 
     * @param {number} [userId] 
     * @param {string} [reasons] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReports(page: number, perPage: number, status?: string, createdAtFrom?: string, createdAtTo?: string, userId?: number, reasons?: string, options?: any) {
        return ReportsApiFp(this.configuration).getReports(page, perPage, status, createdAtFrom, createdAtTo, userId, reasons, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Review report and give feedback to user who reported it
     * @param {ReportsReviewBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reviewReport(body?: ReportsReviewBody, options?: any) {
        return ReportsApiFp(this.configuration).reviewReport(body, options)(this.fetch, this.basePath);
    }

}
/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find artworks by keyword, the search method will find on title, description or tags that contain provided keyword. <br><br>Auth token is optional, but if it's present, it will return an additional keys that only appears in authenticated access only.
         * @summary Search artworks (O)
         * @param {string} keyword 
         * @param {string} range 
         * @param {string} by 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [mode] 
         * @param {boolean} [following] 
         * @param {boolean} [recent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtworks(keyword: string, range: string, by: string, page: number, perPage: number, mode?: string, following?: boolean, recent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'keyword' is not null or undefined
            if (keyword === null || keyword === undefined) {
                throw new RequiredError('keyword','Required parameter keyword was null or undefined when calling searchArtworks.');
            }
            // verify required parameter 'range' is not null or undefined
            if (range === null || range === undefined) {
                throw new RequiredError('range','Required parameter range was null or undefined when calling searchArtworks.');
            }
            // verify required parameter 'by' is not null or undefined
            if (by === null || by === undefined) {
                throw new RequiredError('by','Required parameter by was null or undefined when calling searchArtworks.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling searchArtworks.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling searchArtworks.');
            }
            const localVarPath = `/search/artworks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication none required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (following !== undefined) {
                localVarQueryParameter['following'] = following;
            }

            if (recent !== undefined) {
                localVarQueryParameter['recent'] = recent;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find users by keyword, the search method will find on username, name or pen name that contain provided keyword. <br><br>Auth token is optional, but if token is present it will return an additional keys that only available on authenticated access.
         * @summary Search users (O)
         * @param {string} keyword 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(keyword: string, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'keyword' is not null or undefined
            if (keyword === null || keyword === undefined) {
                throw new RequiredError('keyword','Required parameter keyword was null or undefined when calling searchUsers.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling searchUsers.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling searchUsers.');
            }
            const localVarPath = `/search/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            // authentication none required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find artworks by keyword, the search method will find on title, description or tags that contain provided keyword. <br><br>Auth token is optional, but if it's present, it will return an additional keys that only appears in authenticated access only.
         * @summary Search artworks (O)
         * @param {string} keyword 
         * @param {string} range 
         * @param {string} by 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [mode] 
         * @param {boolean} [following] 
         * @param {boolean} [recent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtworks(keyword: string, range: string, by: string, page: number, perPage: number, mode?: string, following?: boolean, recent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchArtworks(keyword, range, by, page, perPage, mode, following, recent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Find users by keyword, the search method will find on username, name or pen name that contain provided keyword. <br><br>Auth token is optional, but if token is present it will return an additional keys that only available on authenticated access.
         * @summary Search users (O)
         * @param {string} keyword 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(keyword: string, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchUsers(keyword, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Find artworks by keyword, the search method will find on title, description or tags that contain provided keyword. <br><br>Auth token is optional, but if it's present, it will return an additional keys that only appears in authenticated access only.
         * @summary Search artworks (O)
         * @param {string} keyword 
         * @param {string} range 
         * @param {string} by 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {string} [mode] 
         * @param {boolean} [following] 
         * @param {boolean} [recent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtworks(keyword: string, range: string, by: string, page: number, perPage: number, mode?: string, following?: boolean, recent?: boolean, options?: any) {
            return SearchApiFp(configuration).searchArtworks(keyword, range, by, page, perPage, mode, following, recent, options)(fetch, basePath);
        },
        /**
         * Find users by keyword, the search method will find on username, name or pen name that contain provided keyword. <br><br>Auth token is optional, but if token is present it will return an additional keys that only available on authenticated access.
         * @summary Search users (O)
         * @param {string} keyword 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(keyword: string, page: number, perPage: number, options?: any) {
            return SearchApiFp(configuration).searchUsers(keyword, page, perPage, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Find artworks by keyword, the search method will find on title, description or tags that contain provided keyword. <br><br>Auth token is optional, but if it's present, it will return an additional keys that only appears in authenticated access only.
     * @summary Search artworks (O)
     * @param {string} keyword 
     * @param {string} range 
     * @param {string} by 
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {string} [mode] 
     * @param {boolean} [following] 
     * @param {boolean} [recent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchArtworks(keyword: string, range: string, by: string, page: number, perPage: number, mode?: string, following?: boolean, recent?: boolean, options?: any) {
        return SearchApiFp(this.configuration).searchArtworks(keyword, range, by, page, perPage, mode, following, recent, options)(this.fetch, this.basePath);
    }

    /**
     * Find users by keyword, the search method will find on username, name or pen name that contain provided keyword. <br><br>Auth token is optional, but if token is present it will return an additional keys that only available on authenticated access.
     * @summary Search users (O)
     * @param {string} keyword 
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUsers(keyword: string, page: number, perPage: number, options?: any) {
        return SearchApiFp(this.configuration).searchUsers(keyword, page, perPage, options)(this.fetch, this.basePath);
    }

}
/**
 * SettingsApi - fetch parameter creator
 * @export
 */
export const SettingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get setting value
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getSetting.');
            }
            const localVarPath = `/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get setting value
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = SettingsApiFetchParamCreator(configuration).getSetting(key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get setting value
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(key: string, options?: any) {
            return SettingsApiFp(configuration).getSetting(key, options)(fetch, basePath);
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get setting value
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSetting(key: string, options?: any) {
        return SettingsApiFp(this.configuration).getSetting(key, options)(this.fetch, this.basePath);
    }

}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current authenticated user information based on token given on header
         * @summary Get current authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options: any = {}): FetchArgs {
            const localVarPath = `/user/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoById(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserInfoById.');
            }
            const localVarPath = `/user/info/id/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info by Pen Name
         * @param {string} penName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByPenName(penName: string, options: any = {}): FetchArgs {
            // verify required parameter 'penName' is not null or undefined
            if (penName === null || penName === undefined) {
                throw new RequiredError('penName','Required parameter penName was null or undefined when calling getUserInfoByPenName.');
            }
            const localVarPath = `/user/info/pen/{penName}`
                .replace(`{${"penName"}}`, encodeURIComponent(String(penName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByUsername(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getUserInfoByUsername.');
            }
            const localVarPath = `/user/info/username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check is pen name taken or not
         * @param {string} penName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penNameCheck(penName: string, options: any = {}): FetchArgs {
            // verify required parameter 'penName' is not null or undefined
            if (penName === null || penName === undefined) {
                throw new RequiredError('penName','Required parameter penName was null or undefined when calling penNameCheck.');
            }
            const localVarPath = `/user/pen/check/{penName}`
                .replace(`{${"penName"}}`, encodeURIComponent(String(penName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get current authenticated user information based on token given on header
         * @summary Get current authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getCurrentUserInfo(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user info by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoById(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserInfoById(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user info by Pen Name
         * @param {string} penName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByPenName(penName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAllModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserInfoByPenName(penName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user info by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByUsername(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAllModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserInfoByUsername(username, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check is pen name taken or not
         * @param {string} penName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penNameCheck(penName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).penNameCheck(penName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get current authenticated user information based on token given on header
         * @summary Get current authenticated user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options?: any) {
            return UserApiFp(configuration).getCurrentUserInfo(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user info by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoById(userId: string, options?: any) {
            return UserApiFp(configuration).getUserInfoById(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user info by Pen Name
         * @param {string} penName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByPenName(penName: string, options?: any) {
            return UserApiFp(configuration).getUserInfoByPenName(penName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user info by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByUsername(username: string, options?: any) {
            return UserApiFp(configuration).getUserInfoByUsername(username, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check is pen name taken or not
         * @param {string} penName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        penNameCheck(penName: string, options?: any) {
            return UserApiFp(configuration).penNameCheck(penName, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get current authenticated user information based on token given on header
     * @summary Get current authenticated user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUserInfo(options?: any) {
        return UserApiFp(this.configuration).getCurrentUserInfo(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user info by ID
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfoById(userId: string, options?: any) {
        return UserApiFp(this.configuration).getUserInfoById(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user info by Pen Name
     * @param {string} penName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfoByPenName(penName: string, options?: any) {
        return UserApiFp(this.configuration).getUserInfoByPenName(penName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user info by username
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfoByUsername(username: string, options?: any) {
        return UserApiFp(this.configuration).getUserInfoByUsername(username, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check is pen name taken or not
     * @param {string} penName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public penNameCheck(penName: string, options?: any) {
        return UserApiFp(this.configuration).penNameCheck(penName, options)(this.fetch, this.basePath);
    }

}
/**
 * UserChangePasswordApi - fetch parameter creator
 * @export
 */
export const UserChangePasswordApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change current password
         * @param {PasswordRenewBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body?: PasswordRenewBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/password/renew`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordRenewBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to validate current password before changing the password
         * @summary Validate confirmation password
         * @param {CurrentCheckBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCurrentPassword(body?: CurrentCheckBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/password/current/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CurrentCheckBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserChangePasswordApi - functional programming interface
 * @export
 */
export const UserChangePasswordApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change current password
         * @param {PasswordRenewBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body?: PasswordRenewBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserChangePasswordApiFetchParamCreator(configuration).changePassword(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Used to validate current password before changing the password
         * @summary Validate confirmation password
         * @param {CurrentCheckBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCurrentPassword(body?: CurrentCheckBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserChangePasswordApiFetchParamCreator(configuration).checkCurrentPassword(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserChangePasswordApi - factory interface
 * @export
 */
export const UserChangePasswordApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change current password
         * @param {PasswordRenewBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body?: PasswordRenewBody, options?: any) {
            return UserChangePasswordApiFp(configuration).changePassword(body, options)(fetch, basePath);
        },
        /**
         * Used to validate current password before changing the password
         * @summary Validate confirmation password
         * @param {CurrentCheckBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkCurrentPassword(body?: CurrentCheckBody, options?: any) {
            return UserChangePasswordApiFp(configuration).checkCurrentPassword(body, options)(fetch, basePath);
        },
    };
};

/**
 * UserChangePasswordApi - object-oriented interface
 * @export
 * @class UserChangePasswordApi
 * @extends {BaseAPI}
 */
export class UserChangePasswordApi extends BaseAPI {
    /**
     * 
     * @summary Change current password
     * @param {PasswordRenewBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserChangePasswordApi
     */
    public changePassword(body?: PasswordRenewBody, options?: any) {
        return UserChangePasswordApiFp(this.configuration).changePassword(body, options)(this.fetch, this.basePath);
    }

    /**
     * Used to validate current password before changing the password
     * @summary Validate confirmation password
     * @param {CurrentCheckBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserChangePasswordApi
     */
    public checkCurrentPassword(body?: CurrentCheckBody, options?: any) {
        return UserChangePasswordApiFp(this.configuration).checkCurrentPassword(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UserChangeUserMediaApi - fetch parameter creator
 * @export
 */
export const UserChangeUserMediaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change current user avatar
         * @param {Blob} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(avatar?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/user/update/avatar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication bearerAuth required

            if (avatar !== undefined) {
                localVarFormParams.set('avatar', avatar as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change current user cover
         * @param {Blob} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCover(cover?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/user/update/cover`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication bearerAuth required

            if (cover !== undefined) {
                localVarFormParams.set('cover', cover as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserChangeUserMediaApi - functional programming interface
 * @export
 */
export const UserChangeUserMediaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change current user avatar
         * @param {Blob} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(avatar?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserChangeUserMediaApiFetchParamCreator(configuration).updateAvatar(avatar, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Change current user cover
         * @param {Blob} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCover(cover?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = UserChangeUserMediaApiFetchParamCreator(configuration).updateCover(cover, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserChangeUserMediaApi - factory interface
 * @export
 */
export const UserChangeUserMediaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change current user avatar
         * @param {Blob} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(avatar?: Blob, options?: any) {
            return UserChangeUserMediaApiFp(configuration).updateAvatar(avatar, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change current user cover
         * @param {Blob} [cover] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCover(cover?: Blob, options?: any) {
            return UserChangeUserMediaApiFp(configuration).updateCover(cover, options)(fetch, basePath);
        },
    };
};

/**
 * UserChangeUserMediaApi - object-oriented interface
 * @export
 * @class UserChangeUserMediaApi
 * @extends {BaseAPI}
 */
export class UserChangeUserMediaApi extends BaseAPI {
    /**
     * 
     * @summary Change current user avatar
     * @param {Blob} [avatar] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserChangeUserMediaApi
     */
    public updateAvatar(avatar?: Blob, options?: any) {
        return UserChangeUserMediaApiFp(this.configuration).updateAvatar(avatar, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Change current user cover
     * @param {Blob} [cover] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserChangeUserMediaApi
     */
    public updateCover(cover?: Blob, options?: any) {
        return UserChangeUserMediaApiFp(this.configuration).updateCover(cover, options)(this.fetch, this.basePath);
    }

}
/**
 * UserCountersApi - fetch parameter creator
 * @export
 */
export const UserCountersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count how many album do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserAlbums(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countUserAlbums.');
            }
            const localVarPath = `/user/{user_id}/count/album`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count how many artwork album do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworkAlbums(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countUserArtworkAlbums.');
            }
            const localVarPath = `/user/{user_id}/count/album/artwork`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count how many artwork collection do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworkCollections(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countUserArtworkCollections.');
            }
            const localVarPath = `/user/{user_id}/count/collection/artwork`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count how many artworks do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworks(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countUserArtworks.');
            }
            const localVarPath = `/user/{user_id}/count/artwork`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count how many collection do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserCollections(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countUserCollections.');
            }
            const localVarPath = `/user/{user_id}/count/collection`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count how many feeds do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserFeeds(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countUserFeeds.');
            }
            const localVarPath = `/user/{user_id}/count/feed`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserCountersApi - functional programming interface
 * @export
 */
export const UserCountersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count how many album do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserAlbums(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserCountersApiFetchParamCreator(configuration).countUserAlbums(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Count how many artwork album do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworkAlbums(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserCountersApiFetchParamCreator(configuration).countUserArtworkAlbums(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Count how many artwork collection do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworkCollections(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserCountersApiFetchParamCreator(configuration).countUserArtworkCollections(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Count how many artworks do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworks(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserCountersApiFetchParamCreator(configuration).countUserArtworks(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Count how many collection do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserCollections(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserCountersApiFetchParamCreator(configuration).countUserCollections(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Count how many feeds do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserFeeds(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserCountersApiFetchParamCreator(configuration).countUserFeeds(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserCountersApi - factory interface
 * @export
 */
export const UserCountersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count how many album do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserAlbums(userId: number, options?: any) {
            return UserCountersApiFp(configuration).countUserAlbums(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count how many artwork album do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworkAlbums(userId: number, options?: any) {
            return UserCountersApiFp(configuration).countUserArtworkAlbums(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count how many artwork collection do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworkCollections(userId: number, options?: any) {
            return UserCountersApiFp(configuration).countUserArtworkCollections(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count how many artworks do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserArtworks(userId: number, options?: any) {
            return UserCountersApiFp(configuration).countUserArtworks(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count how many collection do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserCollections(userId: number, options?: any) {
            return UserCountersApiFp(configuration).countUserCollections(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count how many feeds do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countUserFeeds(userId: number, options?: any) {
            return UserCountersApiFp(configuration).countUserFeeds(userId, options)(fetch, basePath);
        },
    };
};

/**
 * UserCountersApi - object-oriented interface
 * @export
 * @class UserCountersApi
 * @extends {BaseAPI}
 */
export class UserCountersApi extends BaseAPI {
    /**
     * 
     * @summary Count how many album do user have
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCountersApi
     */
    public countUserAlbums(userId: number, options?: any) {
        return UserCountersApiFp(this.configuration).countUserAlbums(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Count how many artwork album do user have
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCountersApi
     */
    public countUserArtworkAlbums(userId: number, options?: any) {
        return UserCountersApiFp(this.configuration).countUserArtworkAlbums(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Count how many artwork collection do user have
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCountersApi
     */
    public countUserArtworkCollections(userId: number, options?: any) {
        return UserCountersApiFp(this.configuration).countUserArtworkCollections(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Count how many artworks do user have
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCountersApi
     */
    public countUserArtworks(userId: number, options?: any) {
        return UserCountersApiFp(this.configuration).countUserArtworks(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Count how many collection do user have
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCountersApi
     */
    public countUserCollections(userId: number, options?: any) {
        return UserCountersApiFp(this.configuration).countUserCollections(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Count how many feeds do user have
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCountersApi
     */
    public countUserFeeds(userId: number, options?: any) {
        return UserCountersApiFp(this.configuration).countUserFeeds(userId, options)(this.fetch, this.basePath);
    }

}
/**
 * UserFollowingFollowersApi - fetch parameter creator
 * @export
 */
export const UserFollowingFollowersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count how many followers do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFollowers(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countFollowers.');
            }
            const localVarPath = `/user/{user_id}/count/followers`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Count how many users do this person follow
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFollowings(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling countFollowings.');
            }
            const localVarPath = `/user/{user_id}/count/followings`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follow a user
         * @param {number} userIdToFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(userIdToFollow: number, options: any = {}): FetchArgs {
            // verify required parameter 'userIdToFollow' is not null or undefined
            if (userIdToFollow === null || userIdToFollow === undefined) {
                throw new RequiredError('userIdToFollow','Required parameter userIdToFollow was null or undefined when calling followUser.');
            }
            const localVarPath = `/user/follows/follow/{userIdToFollow}`
                .replace(`{${"userIdToFollow"}}`, encodeURIComponent(String(userIdToFollow)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List followers of user of specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followersList(userId: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling followersList.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling followersList.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling followersList.');
            }
            const localVarPath = `/user/follows/followers/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List followed user of specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingList(userId: number, page: number, perPage: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling followingList.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling followingList.');
            }
            // verify required parameter 'perPage' is not null or undefined
            if (perPage === null || perPage === undefined) {
                throw new RequiredError('perPage','Required parameter perPage was null or undefined when calling followingList.');
            }
            const localVarPath = `/user/follows/following/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check is user login following specific user
         * @param {number} userIdToCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isFollowing(userIdToCheck: number, options: any = {}): FetchArgs {
            // verify required parameter 'userIdToCheck' is not null or undefined
            if (userIdToCheck === null || userIdToCheck === undefined) {
                throw new RequiredError('userIdToCheck','Required parameter userIdToCheck was null or undefined when calling isFollowing.');
            }
            const localVarPath = `/user/follows/is-following/{userIdToCheck}`
                .replace(`{${"userIdToCheck"}}`, encodeURIComponent(String(userIdToCheck)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {number} userIdToUnfollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(userIdToUnfollow: number, options: any = {}): FetchArgs {
            // verify required parameter 'userIdToUnfollow' is not null or undefined
            if (userIdToUnfollow === null || userIdToUnfollow === undefined) {
                throw new RequiredError('userIdToUnfollow','Required parameter userIdToUnfollow was null or undefined when calling unfollowUser.');
            }
            const localVarPath = `/user/follows/unfollow/{userIdToUnfollow}`
                .replace(`{${"userIdToUnfollow"}}`, encodeURIComponent(String(userIdToUnfollow)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserFollowingFollowersApi - functional programming interface
 * @export
 */
export const UserFollowingFollowersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Count how many followers do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFollowers(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserFollowingFollowersApiFetchParamCreator(configuration).countFollowers(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Count how many users do this person follow
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFollowings(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CounterModel> {
            const localVarFetchArgs = UserFollowingFollowersApiFetchParamCreator(configuration).countFollowings(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Follow a user
         * @param {number} userIdToFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(userIdToFollow: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserFollowingFollowersApiFetchParamCreator(configuration).followUser(userIdToFollow, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List followers of user of specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followersList(userId: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = UserFollowingFollowersApiFetchParamCreator(configuration).followersList(userId, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List followed user of specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingList(userId: number, page: number, perPage: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = UserFollowingFollowersApiFetchParamCreator(configuration).followingList(userId, page, perPage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check is user login following specific user
         * @param {number} userIdToCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isFollowing(userIdToCheck: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = UserFollowingFollowersApiFetchParamCreator(configuration).isFollowing(userIdToCheck, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {number} userIdToUnfollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(userIdToUnfollow: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserFollowingFollowersApiFetchParamCreator(configuration).unfollowUser(userIdToUnfollow, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserFollowingFollowersApi - factory interface
 * @export
 */
export const UserFollowingFollowersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count how many followers do user have
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFollowers(userId: number, options?: any) {
            return UserFollowingFollowersApiFp(configuration).countFollowers(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count how many users do this person follow
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countFollowings(userId: number, options?: any) {
            return UserFollowingFollowersApiFp(configuration).countFollowings(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Follow a user
         * @param {number} userIdToFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(userIdToFollow: number, options?: any) {
            return UserFollowingFollowersApiFp(configuration).followUser(userIdToFollow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List followers of user of specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followersList(userId: number, page: number, perPage: number, options?: any) {
            return UserFollowingFollowersApiFp(configuration).followersList(userId, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List followed user of specific user
         * @param {number} userId 
         * @param {number} page Pagination index
         * @param {number} perPage How many record to show per page of pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followingList(userId: number, page: number, perPage: number, options?: any) {
            return UserFollowingFollowersApiFp(configuration).followingList(userId, page, perPage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check is user login following specific user
         * @param {number} userIdToCheck 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isFollowing(userIdToCheck: number, options?: any) {
            return UserFollowingFollowersApiFp(configuration).isFollowing(userIdToCheck, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {number} userIdToUnfollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(userIdToUnfollow: number, options?: any) {
            return UserFollowingFollowersApiFp(configuration).unfollowUser(userIdToUnfollow, options)(fetch, basePath);
        },
    };
};

/**
 * UserFollowingFollowersApi - object-oriented interface
 * @export
 * @class UserFollowingFollowersApi
 * @extends {BaseAPI}
 */
export class UserFollowingFollowersApi extends BaseAPI {
    /**
     * 
     * @summary Count how many followers do user have
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFollowingFollowersApi
     */
    public countFollowers(userId: number, options?: any) {
        return UserFollowingFollowersApiFp(this.configuration).countFollowers(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Count how many users do this person follow
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFollowingFollowersApi
     */
    public countFollowings(userId: number, options?: any) {
        return UserFollowingFollowersApiFp(this.configuration).countFollowings(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Follow a user
     * @param {number} userIdToFollow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFollowingFollowersApi
     */
    public followUser(userIdToFollow: number, options?: any) {
        return UserFollowingFollowersApiFp(this.configuration).followUser(userIdToFollow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List followers of user of specific user
     * @param {number} userId 
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFollowingFollowersApi
     */
    public followersList(userId: number, page: number, perPage: number, options?: any) {
        return UserFollowingFollowersApiFp(this.configuration).followersList(userId, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List followed user of specific user
     * @param {number} userId 
     * @param {number} page Pagination index
     * @param {number} perPage How many record to show per page of pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFollowingFollowersApi
     */
    public followingList(userId: number, page: number, perPage: number, options?: any) {
        return UserFollowingFollowersApiFp(this.configuration).followingList(userId, page, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check is user login following specific user
     * @param {number} userIdToCheck 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFollowingFollowersApi
     */
    public isFollowing(userIdToCheck: number, options?: any) {
        return UserFollowingFollowersApiFp(this.configuration).isFollowing(userIdToCheck, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unfollow a user
     * @param {number} userIdToUnfollow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFollowingFollowersApi
     */
    public unfollowUser(userIdToUnfollow: number, options?: any) {
        return UserFollowingFollowersApiFp(this.configuration).unfollowUser(userIdToUnfollow, options)(this.fetch, this.basePath);
    }

}
/**
 * UserForgotPasswordApi - fetch parameter creator
 * @export
 */
export const UserForgotPasswordApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if recovery token is still valid
         * @param {string} token1 
         * @param {string} token2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkResetPasswordTokenValidity(token1: string, token2: string, options: any = {}): FetchArgs {
            // verify required parameter 'token1' is not null or undefined
            if (token1 === null || token1 === undefined) {
                throw new RequiredError('token1','Required parameter token1 was null or undefined when calling checkResetPasswordTokenValidity.');
            }
            // verify required parameter 'token2' is not null or undefined
            if (token2 === null || token2 === undefined) {
                throw new RequiredError('token2','Required parameter token2 was null or undefined when calling checkResetPasswordTokenValidity.');
            }
            const localVarPath = `/user/password/recover/token-validity/{token1}/{token2}`
                .replace(`{${"token1"}}`, encodeURIComponent(String(token1)))
                .replace(`{${"token2"}}`, encodeURIComponent(String(token2)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change password
         * @param {RecoverChangeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverChangePassword(body?: RecoverChangeBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/password/recover/change`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RecoverChangeBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a password recovery request to email address
         * @param {PasswordForgotBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResetPasswordInstruction(body?: PasswordForgotBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/password/forgot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordForgotBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserForgotPasswordApi - functional programming interface
 * @export
 */
export const UserForgotPasswordApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check if recovery token is still valid
         * @param {string} token1 
         * @param {string} token2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkResetPasswordTokenValidity(token1: string, token2: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = UserForgotPasswordApiFetchParamCreator(configuration).checkResetPasswordTokenValidity(token1, token2, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Change password
         * @param {RecoverChangeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverChangePassword(body?: RecoverChangeBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserForgotPasswordApiFetchParamCreator(configuration).recoverChangePassword(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send a password recovery request to email address
         * @param {PasswordForgotBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResetPasswordInstruction(body?: PasswordForgotBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserForgotPasswordApiFetchParamCreator(configuration).sendResetPasswordInstruction(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserForgotPasswordApi - factory interface
 * @export
 */
export const UserForgotPasswordApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Check if recovery token is still valid
         * @param {string} token1 
         * @param {string} token2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkResetPasswordTokenValidity(token1: string, token2: string, options?: any) {
            return UserForgotPasswordApiFp(configuration).checkResetPasswordTokenValidity(token1, token2, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change password
         * @param {RecoverChangeBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverChangePassword(body?: RecoverChangeBody, options?: any) {
            return UserForgotPasswordApiFp(configuration).recoverChangePassword(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send a password recovery request to email address
         * @param {PasswordForgotBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendResetPasswordInstruction(body?: PasswordForgotBody, options?: any) {
            return UserForgotPasswordApiFp(configuration).sendResetPasswordInstruction(body, options)(fetch, basePath);
        },
    };
};

/**
 * UserForgotPasswordApi - object-oriented interface
 * @export
 * @class UserForgotPasswordApi
 * @extends {BaseAPI}
 */
export class UserForgotPasswordApi extends BaseAPI {
    /**
     * 
     * @summary Check if recovery token is still valid
     * @param {string} token1 
     * @param {string} token2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserForgotPasswordApi
     */
    public checkResetPasswordTokenValidity(token1: string, token2: string, options?: any) {
        return UserForgotPasswordApiFp(this.configuration).checkResetPasswordTokenValidity(token1, token2, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Change password
     * @param {RecoverChangeBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserForgotPasswordApi
     */
    public recoverChangePassword(body?: RecoverChangeBody, options?: any) {
        return UserForgotPasswordApiFp(this.configuration).recoverChangePassword(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send a password recovery request to email address
     * @param {PasswordForgotBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserForgotPasswordApi
     */
    public sendResetPasswordInstruction(body?: PasswordForgotBody, options?: any) {
        return UserForgotPasswordApiFp(this.configuration).sendResetPasswordInstruction(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UserUpdateUserInfoApi - fetch parameter creator
 * @export
 */
export const UserUpdateUserInfoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change username
         * @param {UpdateUsernameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUsername(body?: UpdateUsernameBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/update/username`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsernameBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user information
         * @param {UpdateInfoBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfo(body?: UpdateInfoBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/update/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateInfoBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user settings
         * @param {UpdatePreferenceBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreference(body?: UpdatePreferenceBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/update/preference`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePreferenceBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user social links
         * @param {UpdateSocialBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSocial(body?: UpdateSocialBody, options: any = {}): FetchArgs {
            const localVarPath = `/user/update/social`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSocialBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserUpdateUserInfoApi - functional programming interface
 * @export
 */
export const UserUpdateUserInfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change username
         * @param {UpdateUsernameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUsername(body?: UpdateUsernameBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserUpdateUserInfoApiFetchParamCreator(configuration).changeUsername(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update user information
         * @param {UpdateInfoBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfo(body?: UpdateInfoBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserUpdateUserInfoApiFetchParamCreator(configuration).updateUserInfo(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update user settings
         * @param {UpdatePreferenceBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreference(body?: UpdatePreferenceBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserUpdateUserInfoApiFetchParamCreator(configuration).updateUserPreference(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update user social links
         * @param {UpdateSocialBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSocial(body?: UpdateSocialBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessMessageModel> {
            const localVarFetchArgs = UserUpdateUserInfoApiFetchParamCreator(configuration).updateUserSocial(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserUpdateUserInfoApi - factory interface
 * @export
 */
export const UserUpdateUserInfoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change username
         * @param {UpdateUsernameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUsername(body?: UpdateUsernameBody, options?: any) {
            return UserUpdateUserInfoApiFp(configuration).changeUsername(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update user information
         * @param {UpdateInfoBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfo(body?: UpdateInfoBody, options?: any) {
            return UserUpdateUserInfoApiFp(configuration).updateUserInfo(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update user settings
         * @param {UpdatePreferenceBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreference(body?: UpdatePreferenceBody, options?: any) {
            return UserUpdateUserInfoApiFp(configuration).updateUserPreference(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update user social links
         * @param {UpdateSocialBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSocial(body?: UpdateSocialBody, options?: any) {
            return UserUpdateUserInfoApiFp(configuration).updateUserSocial(body, options)(fetch, basePath);
        },
    };
};

/**
 * UserUpdateUserInfoApi - object-oriented interface
 * @export
 * @class UserUpdateUserInfoApi
 * @extends {BaseAPI}
 */
export class UserUpdateUserInfoApi extends BaseAPI {
    /**
     * 
     * @summary Change username
     * @param {UpdateUsernameBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserUpdateUserInfoApi
     */
    public changeUsername(body?: UpdateUsernameBody, options?: any) {
        return UserUpdateUserInfoApiFp(this.configuration).changeUsername(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update user information
     * @param {UpdateInfoBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserUpdateUserInfoApi
     */
    public updateUserInfo(body?: UpdateInfoBody, options?: any) {
        return UserUpdateUserInfoApiFp(this.configuration).updateUserInfo(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update user settings
     * @param {UpdatePreferenceBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserUpdateUserInfoApi
     */
    public updateUserPreference(body?: UpdatePreferenceBody, options?: any) {
        return UserUpdateUserInfoApiFp(this.configuration).updateUserPreference(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update user social links
     * @param {UpdateSocialBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserUpdateUserInfoApi
     */
    public updateUserSocial(body?: UpdateSocialBody, options?: any) {
        return UserUpdateUserInfoApiFp(this.configuration).updateUserSocial(body, options)(this.fetch, this.basePath);
    }

}
